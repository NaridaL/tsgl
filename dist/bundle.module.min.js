function isArray(t){return Array==t.constructor||Float32Array==t.constructor||Float64Array==t.constructor}function currentGL(){return LightGLContext.gl}function pushQuad(t,e,r,i,s,o){e?t.push(r,s,i,i,s,o):t.push(r,i,s,i,o,s)}function hexIntToGLColor(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}import chroma from"chroma-js";class Mesh extends Transformable{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","LGL_Vertex")}calcVolume(){let t=0,e=V3.O,r=0;const i=this.TRIANGLES,s=this.vertices;for(let o=0;o<i.length;o+=3){const n=i[o+0],a=i[o+1],h=i[o+2],c=s[n],d=s[a],l=s[h],u=d.minus(c),f=l.minus(c),m=u.cross(f),L=c.plus(d.plus(l)).div(3);t+=L.z*m.z/2,r+=m.length(),e=e.plus(new V3(L.x,L.y,L.z/2).times(L.z*m.z/2))}return{volume:t,centroid:e.div(i.length/3),area:r/2}}addVertexBuffer(t,e){return assert(!this.vertexBuffers[e]),this.hasBeenCompiled=!1,assert("string"==typeof t),assert("string"==typeof e),(this.vertexBuffers[e]=new Buffer(WGL$1.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t){return this.hasBeenCompiled=!1,(this.indexBuffers[t]=new Buffer(WGL$1.ELEMENT_ARRAY_BUFFER,Uint16Array)).name=t,this[t]=[],this}concat(...t){const e=new Mesh;return[this].concat(t).forEach(t=>{const r=e.vertices?e.vertices.length:0;Object.getOwnPropertyNames(t.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r].name;e.vertexBuffers[r]||e.addVertexBuffer(i,r),e[i].push(t[i])}),Object.getOwnPropertyNames(t.indexBuffers).forEach(i=>{e.indexBuffers[i]||e.addIndexBuffer(i),e[i].push(...t[i].map(t=>t+r))})}),e}compile(){Object.getOwnPropertyNames(this.vertexBuffers).forEach(t=>{const e=this.vertexBuffers[t];e.data=this[e.name],e.compile()});for(const t in this.indexBuffers){const e=this.indexBuffers[t];e.data=this[e.name],e.compile()}this.hasBeenCompiled=!0}toBinarySTL(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const t=this.TRIANGLES,e=t.length/3,r=new ArrayBuffer(84+50*e),i=new DataView(r);i.setUint32(80,e,!0);let s=84,o=t.length;for(;o;){o-=3;const e=this.vertices[t[o]],r=this.vertices[t[o+1]],n=this.vertices[t[o+2]];[V3.normalOnPoints(e,r,n),e,r,n].forEach(t=>{i.setFloat32(s,t.x,!0),s+=4,i.setFloat32(s,t.y,!0),s+=4,i.setFloat32(s,t.z,!0),s+=4}),s+=2}return assert(s==r.byteLength,s+" "+r.byteLength),new Blob([r],{type:"application/octet-stream"})}transform(t){const e=new Mesh;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","LGL_Normal");const r=t.as3x3().inversed().transposed().normalized();e.normals=this.normals.map(t=>r.transformVector(t)),e.normals.forEach(t=>assert(t.hasLength(1)))}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];return e.compile(),e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","LGL_Normal"),this.vertexBuffers.LGL_Normal.data=arrayFromFunction(this.vertices.length,t=>V3.O);const t=this.TRIANGLES,e=this.vertices,r=this.normals;for(let i=0;i<t.length;i+=3){const s=t[i],o=t[i+1],n=t[i+2],a=e[s],h=e[o],c=e[n],d=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s].plus(d),r[o]=r[o].plus(d),r[n]=r[n].plus(d)}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this}computeWireframeFromFlatTriangles(t="LINES"){function e(t,e){return min(t,e)<<16|max(t,e)}if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const r=new Set,i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)r.add(e(i[t+0],i[t+1])),r.add(e(i[t+1],i[t+2])),r.add(e(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),r.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const t=this.TRIANGLES,e=this.LINES;for(let r=0;r<t.length;r+=3)t[r+0]<t[r+1]&&e.push(t[r+0],t[r+1]),t[r+1]<t[r+2]&&e.push(t[r+1],t[r+2]),t[r+2]<t[r+0]&&e.push(t[r+2],t[r+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.vertices||!this.normals)throw new Error("Both vertices and normals must be defined.");const r=this.vertices,i=this.vertices.length,s=e;this[s]||this.addIndexBuffer(e);for(let e=0;e<this.normals.length;e++)r[i+e]=r[e].plus(this.normals[e].toLength(t)),this[s].push(i+e,e);return this.hasBeenCompiled=!1,this}getAABB(){return(new AABB).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const e=t.detailX||t.detail||1,r=t.detailY||t.detail||1,i=t.startX||0,s=t.startY||0,o=t.width||1,n=t.height||1,a=(new Mesh).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal").addVertexBuffer("coords","LGL_TexCoord");for(let t=0;t<=r;t++){const h=t/r;for(let c=0;c<=e;c++){const d=c/e;if(a.vertices.push(new V3(i+d*o,s+h*n,0)),a.coords.push(d,h),a.normals.push(V3.Z),c<e&&t<r){const r=c+t*(e+1);a.TRIANGLES.push(r,r+e+1,r+1,r+e+1,r+e+2,r+1)}}}for(let t=0;t<e;t++)a.LINES.push(t,t+1),a.LINES.push((e+1)*r+t,(e+1)*r+t+1);for(let t=0;t<r;t++)a.LINES.push(e*t,e*(t+1)+1),a.LINES.push(e*(t+1),e*(t+2)+1);return a.compile(),a}static cube(){const t=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e=[0,1,2,3,4,5,6,7,0,4,1,5,2,6,3,7,2,6,0,4,3,7,1,5];t.vertices=e.map(t=>Mesh.UNIT_CUBE_CORNERS[t]),t.normals=[V3.X.negated(),V3.X,V3.Y.negated(),V3.Y,V3.Z.negated(),V3.Z].map(t=>[t,t,t,t]).concatenated();for(let r=0;r<24;r+=4)pushQuad(t.TRIANGLES,0!=r%8,e[r],e[r+1],e[r+2],e[r+3]);return t.LINES=[0,1,0,2,1,3,2,3,0,4,1,5,2,6,3,7,4,5,4,6,5,7,6,7].map(t=>e.indexOf(t)),t.compile(),t}static isocahedron(){return Mesh.sphere(0)}static sphere2(t,e){const r=arrayFromFunction(t,e=>{const r=e/(t-1)*PI-PI/2;return new V3(0,cos(r),sin(r))});return Mesh.rotation(r,{anchor:V3.O,dir1:V3.Z},2*PI,e,!0,r)}static sphere(t=3){function e(t,r,i,s,o,n,a,h,c,d){if(0==s)n.push(a,h,c),a<h&&d.push(a,h),h<c&&d.push(h,c),c<a&&d.push(c,a);else{const l=t.plus(r).toLength(1),u=r.plus(i).toLength(1),f=i.plus(t).toLength(1),m=o.length,L=m+1,E=m+2;o.push(l,u,f),e(l,u,f,s-1,o,n,m,L,E,d),e(t,l,f,s-1,o,n,a,m,E,d),e(r,u,l,s-1,o,n,h,L,m,d),e(i,f,u,s-1,o,n,c,E,L,d)}}const r=(1+Math.sqrt(5))/2,i=new V3(1,r,0).unit(),s=i.x,o=i.y,n=[new V3(-s,o,0),new V3(s,o,0),new V3(-s,-o,0),new V3(s,-o,0),new V3(0,-s,o),new V3(0,s,o),new V3(0,-s,-o),new V3(0,s,-o),new V3(o,0,-s),new V3(o,0,s),new V3(-o,0,-s),new V3(-o,0,s)],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],h=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");h.vertices.push(...n),t=void 0==t?4:t;for(let r=0;r<20;r++){const[i,s,o]=a.slice(3*r,3*r+3);e(n[i],n[s],n[o],t,h.vertices,h.TRIANGLES,i,s,o,h.LINES)}return h.normals=h.vertices,h.compile(),h}static aabb(t){const e=M4.multiplyMultiple(M4.translate(t.min),M4.scale(t.size().max(new V3(NLA_PRECISION,NLA_PRECISION,NLA_PRECISION)))),r=Mesh.cube().transform(e);return r.computeNormalLines(20),r.compile(),r}static offsetVertices(t,e,r,i,s){assertVectors.apply(void 0,t),assertVectors(e);const o=(new Mesh).addIndexBuffer("TRIANGLES");i&&o.addVertexBuffer("normals","LGL_Normal"),o.vertices=t.concat(t.map(t=>t.plus(e)));const n=o.TRIANGLES;for(let e=0;e<t.length-1;e++)pushQuad(n,!1,e,e+1,t.length+e,t.length+e+1);return r&&pushQuad(n,!1,0,t.length-1,t.length,2*t.length-1),i&&(o.normals=i.concat(i)),o.compile(),o}static rotation(t,e,r,i,s=!0,o){const n=(new Mesh).addIndexBuffer("TRIANGLES");o&&n.addVertexBuffer("normals","LGL_Normal");const a=t.length,h=a*i,c=new M4,d=n.TRIANGLES;for(let l=0;l<i;l++){const u=r/i*l;if(M4.rotateLine(e.anchor,e.dir1,u,c),n.vertices.push(...c.transformedPoints(t)),o&&n.normals.push(...c.transformedVectors(o)),s||l!==i-1)for(let t=0;t<a-1;t++)pushQuad(d,!1,l*a+t+1,l*a+t,((l+1)*a+t+1)%h,((l+1)*a+t)%h)}return n.compile(),n}static parametric(t,e,r,i,s,o,n,a){const h=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES");for(let c=0;c<=n;c++){const d=lerp(r,i,c/n);for(let r=0;r<=a;r++){const i=lerp(s,o,r/a);if(h.vertices.push(t(d,i)),h.normals.push(e(d,i)),r<a&&c<n){const t=r+c*(a+1);pushQuad(h.TRIANGLES,!1,t,t+a+1,t+1,t+a+2)}}}return h.compile(),h}}Mesh.UNIT_CUBE_CORNERS=[V3.O,new V3(0,0,1),new V3(0,1,0),new V3(0,1,1),new V3(1,0,0),new V3(1,0,1),new V3(1,1,0),V3.XYZ];const DRAW_MODE_CHECKS={[DRAW_MODES.POINTS]:t=>!0,[DRAW_MODES.LINES]:t=>0==t%2,[DRAW_MODES.LINE_STRIP]:t=>t>2,[DRAW_MODES.LINE_LOOP]:t=>t>2,[DRAW_MODES.TRIANGLES]:t=>0==t%3,[DRAW_MODES.TRIANGLE_STRIP]:t=>t>3,[DRAW_MODES.TRIANGLE_FAN]:t=>t>3};class Shader{constructor(t,e,r=currentGL()){function i(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,WGL$1.COMPILE_STATUS))throw new Error("compile error: "+r.getShaderInfoLog(i));return i}this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1;const s=`\n\t\tuniform mat3 LGL_NormalMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrix;\n\t\tuniform mat4 LGL_ProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrixInverse;\n\t\tuniform mat4 LGL_ProjectionMatrixInverse;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrixInverse;\n\t`,o=s+`\n\t\tattribute vec4 LGL_Vertex;\n\t\tattribute vec4 LGL_TexCoord;\n\t\tattribute vec3 LGL_Normal;\n\t\tattribute vec4 LGL_Color;\n\t`,n=`  precision highp float;`+s,a=s.match(/\bLGL_\w+/g);this.gl=r;const h=r.createProgram();if(h||r.handleError(),this.program=h,r.attachShader(this.program,i(WGL$1.VERTEX_SHADER,o+t)),r.attachShader(this.program,i(WGL$1.FRAGMENT_SHADER,n+e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,WGL$1.LINK_STATUS))throw new Error("link error: "+r.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={},this.activeMatrices={},a&&a.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,WGL$1.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}r.handleError()}static create(t,e){return new Shader(t,e)}uniforms(t){const e=this.gl;e.useProgram(this.program),e.handleError();for(const r in t){const i=this.uniformLocations[r]||e.getUniformLocation(this.program,r);if(assert(!!i,r+" uniform is not used in shader"),!i)continue;this.uniformLocations[r]=i;let s=t[r];const o=this.uniformInfos[r];if(NLA_DEBUG&&(assert(o.type!=WGL$1.FLOAT||1==o.size&&"number"==typeof s||isArray(s)&&o.size==s.length&&assertNumbers.apply(void 0,s)),assert(o.type!=WGL$1.INT||1==o.size&&"number"==typeof s&&s%1==0||isArray(s)&&o.size==s.length&&assertNumbers.apply(void 0,s)&&s.every(t=>t%1==0)),assert(o.type!=WGL$1.FLOAT_VEC3||1==o.size&&s instanceof V3||isArray(s)&&o.size==s.length&&assertVectors.apply(void 0,s)),assert(o.type!=WGL$1.FLOAT_VEC4||isArray(s)&&4==s.length),assert(o.type!=WGL$1.FLOAT_MAT4||s instanceof M4,()=>s.toSource()),assert(o.type!=WGL$1.FLOAT_MAT3||9==s.length||s instanceof M4)),s instanceof V3&&(s=s.toArray()),isArray(s))switch(s.length){case 1:e.uniform1fv(i,s);break;case 2:e.uniform2fv(i,s);break;case 3:e.uniform3fv(i,s);break;case 4:e.uniform4fv(i,s);break;case 9:e.uniformMatrix3fv(i,!1,new Float32Array([s[0],s[3],s[6],s[1],s[4],s[7],s[2],s[5],s[8]]));break;case 16:e.uniformMatrix4fv(i,!1,new Float32Array([s[0],s[4],s[8],s[12],s[1],s[5],s[9],s[13],s[2],s[6],s[10],s[14],s[3],s[7],s[11],s[15]]));break;default:throw new Error("don't know how to load uniform \""+r+'" of length '+s.length)}else if(Number.isInteger(s))WGL$1.SAMPLER_2D==o.type||WGL$1.SAMPLER_CUBE==o.type||WGL$1.INT==o.type?e.uniform1i(i,s):e.uniform1f(i,s);else{if(!(s instanceof M4))throw new Error('attempted to set uniform "'+r+'" to invalid value '+s);{const t=s.m;if(WGL$1.FLOAT_MAT4==o.type)e.uniformMatrix4fv(i,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(WGL$1.FLOAT_MAT3==o.type)e.uniformMatrix3fv(i,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(WGL$1.FLOAT_MAT2!=o.type)throw new Error(`Can't assign M4 to ${o.type}`);e.uniformMatrix2fv(i,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}e.handleError()}return this}draw(t,e=DRAW_MODES.TRIANGLES,r,i){assert(t.hasBeenCompiled,"mesh.hasBeenCompiled"),assert(void 0!=DRAW_MODES[e]);const s=DRAW_MODES[e];return assert(t.indexBuffers[s],`mesh.indexBuffers[${s}] undefined`),this.drawBuffers(t.vertexBuffers,t.indexBuffers[s],e,r,i)}drawBuffers(t,e,r=DRAW_MODES.TRIANGLES,i=0,s){const o=this.gl;o.handleError(),assert(void 0!=DRAW_MODES[r]),assertf(()=>1<=Object.keys(t).length),Object.keys(t).forEach(e=>assertInst(Buffer,t[e]));const n=this.activeMatrices,a=(n.LGL_ModelViewMatrixInverse||n.LGL_NormalMatrix)&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&o.modelViewMatrix.inversed(),h=n.LGL_ProjectionMatrixInverse&&this.projectionMatrixVersion!=o.projectionMatrixVersion&&o.projectionMatrix.inversed(),c=(n.LGL_ModelViewProjectionMatrix||n.LGL_ModelViewProjectionMatrixInverse)&&(this.projectionMatrixVersion!=o.projectionMatrixVersion||this.modelViewMatrixVersion!=o.modelViewMatrixVersion)&&o.projectionMatrix.times(o.modelViewMatrix),d={};n.LGL_ModelViewMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(d.LGL_ModelViewMatrix=o.modelViewMatrix),n.LGL_ModelViewMatrixInverse&&(d.LGL_ModelViewMatrixInverse=a),n.LGL_ProjectionMatrix&&this.projectionMatrixVersion!=o.projectionMatrixVersion&&(d.LGL_ProjectionMatrix=o.projectionMatrix),h&&(d.LGL_ProjectionMatrixInverse=h),c&&(d.LGL_ModelViewProjectionMatrix=c),c&&n.LGL_ModelViewProjectionMatrixInverse&&(d.LGL_ModelViewProjectionMatrixInverse=c.inversed()),n.LGL_NormalMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(d.LGL_NormalMatrix=a.transposed()),this.uniforms(d),this.projectionMatrixVersion=o.projectionMatrixVersion,this.modelViewMatrixVersion=o.modelViewMatrixVersion;let l=1/0;for(const e in t){const r=t[e];assert(r.hasBeenCompiled);const i=this.attributes[e]||o.getAttribLocation(this.program,e);o.handleError(),-1!=i&&r.buffer&&(this.attributes[e]=i,o.bindBuffer(WGL$1.ARRAY_BUFFER,r.buffer),o.handleError(),o.enableVertexAttribArray(i),o.handleError(),o.vertexAttribPointer(i,r.spacing,WGL$1.FLOAT,!1,0,0),o.handleError(),l=Math.min(l,r.count))}for(const e in this.attributes)e in t||(o.disableVertexAttribArray(this.attributes[e]),o.handleError());if(l){if(s=s||(e?e.count:l),assert(DRAW_MODE_CHECKS[r](s),"count "+s+" doesn't fulfill requirement "+DRAW_MODE_CHECKS[r].toString()+" for mode "+DRAW_MODES[r]),e){if(assert(e.hasBeenCompiled),assert(l>e.maxValue),assert(s%e.spacing==0),assert(i%e.spacing==0),i+s>e.count)throw new Error("Buffer not long enough for passed parameters start/length/buffer length "+i+" "+s+" "+e.count);o.bindBuffer(WGL$1.ELEMENT_ARRAY_BUFFER,e.buffer),o.handleError(),o.drawElements(r,s,WGL$1.UNSIGNED_SHORT,2*i),o.handleError()}else{if(i+s>l)throw new Error("invalid");o.drawArrays(r,i,s),o.handleError()}o.drawCallCount++}return this}}const WGL$1=WebGLRenderingContext;class LightGLContext extends WebGLRenderingContext{constructor(){super(),this.modelViewMatrix=new M4,this.projectionMatrix=new M4,this.MODELVIEW={},this.PROJECTION={},this.tempMatrix=new M4,this.resultMatrix=new M4,this.modelViewStack=[],this.projectionStack=[]}init(){this.modelViewMatrix=new M4,this.projectionMatrix=new M4,this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.tempMatrix=new M4,this.resultMatrix=new M4,this.modelViewStack=[],this.projectionStack=[],this.immediate={mesh:(new Mesh).addVertexBuffer("coords","LGL_TexCoord").addVertexBuffer("vertices","LGL_Vertex").addVertexBuffer("colors","LGL_Color"),mode:-1,coord:[0,0,0,0],color:[1,1,1,1],pointSize:1,shader:new Shader(`\nuniform float pointSize;\nvarying vec4 color;\nvarying vec4 coord;\nvoid main() {\n\tcolor = LGL_Color;\n\tcoord = LGL_TexCoord;\n\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\tgl_PointSize = pointSize;\n}`,`\nuniform sampler2D texture;\nuniform float pointSize;\nuniform bool useTexture;\nvarying vec4 color;\nvarying vec4 coord;\nvoid main() {\n\tgl_FragColor = color;\n\tif (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n}`)},this.matrixMode(LightGLContext.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw new Error("invalid matrix mode "+t)}}modelViewMode(){Object.defineProperty(LightGLContext.gl,"currentMatrix",{get:function(){return this.modelViewMatrix},set:function(t){this.modelViewMatrix=t},writable:!0}),this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack}projectionMode(){this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack}loadIdentity(){M4.identity(this[this.currentMatrixName])}loadMatrix(t){M4.copy(t,this[this.currentMatrixName])}multMatrix(t){M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const e=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=e,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(M4.mirror(t))}perspective(t,e,r,i,s){this.multMatrix(M4.perspectiveRad(t*DEG,e,r,i,this.tempMatrix))}frustum(t,e,r,i,s,o){this.multMatrix(M4.frustum(t,e,r,i,s,o,this.tempMatrix))}ortho(t,e,r,i,s,o){this.multMatrix(M4.ortho(t,e,r,i,s,o,this.tempMatrix))}scale(...t){this.multMatrix(M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(M4.mirror(P3ZX))}translate(t,e,r){void 0!==e?this.multMatrix(M4.translate(t,e,r,this.tempMatrix)):this.multMatrix(M4.translate(t,this.tempMatrix))}rotate(t,e,r,i){this.multMatrix(M4.rotate(t,{x:e,y:r,z:i},this.tempMatrix))}lookAt(t,e,r){this.multMatrix(M4.lookAt(t,e,r,this.tempMatrix))}pushMatrix(){this.stack.push(M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();assert(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[e,r,i,s]=t,o=new M4([i/2,0,0,e+i/2,s/2,0,0,r+s/2,0,0,1,0,0,0,0,1]);return M4.multiplyMultiple(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw new Error("mismatched begin() and end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?hexIntToGLColor(t[0]):1==t.length&&"string"==typeof t[0]?chroma(t[0]).gl():[t[0],t[1],t[2],t[3]||0]}texCoord(...t){this.immediate.coord=V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!LightGLContext.gl.getParameter(WGL$1.TEXTURE_BINDING_2D)}).draw(this.immediate.mesh,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){LightGLContext.gl=this}animate(){const t=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let e=(new Date).getTime();const r=()=>{const i=(new Date).getTime();this.onupdate&&this.onupdate(i-e),this.ondraw&&this.ondraw(),t(r),e=i};r()}fullscreen(t={}){function e(){n.canvas.width=window.innerWidth-i-s,n.canvas.height=window.innerHeight-r-o,n.viewport(0,0,n.canvas.width,n.canvas.height),t.camera&&(n.matrixMode(LightGLContext.PROJECTION),n.loadIdentity(),n.perspective(t.fov||45,n.canvas.width/n.canvas.height,t.near||.1,t.far||1e3),n.matrixMode(LightGLContext.MODELVIEW)),n.ondraw&&n.ondraw()}const r=t.paddingTop||0,i=t.paddingLeft||0,s=t.paddingRight||0,o=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");document.body.appendChild(this.canvas),document.body.style.overflow="hidden",this.canvas.style.position="absolute",this.canvas.style.left=i+"px",this.canvas.style.top=r+"px";const n=this;window.addEventListener("resize",e),e()}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}handleError(){const t=this.getError();if(0!==t)throw new Error(""+t+WGL_ERROR[t])}static create(t={}){const e=t.canvas||document.createElement("canvas");t.canvas||(e.width=800,e.height=600),"alpha"in t||(t.alpha=!1);let r=void 0;try{r=e.getContext("webgl",t),console.log("getting context")}catch(t){console.log(t,r)}try{r=r||e.getContext("experimental-webgl",t)}catch(t){console.log(t,r)}if(!r)throw new Error("WebGL not supported");return addOwnProperties(r,LightGLContext.prototype),LightGLContext.gl=r,r.init(),r}}LightGLContext.MODELVIEW={},LightGLContext.PROJECTION={},LightGLContext.HALF_FLOAT_OES=36193;var WGL_ERROR;!function(t){t[t.NO_ERROR=WGL$1.NO_ERROR]="NO_ERROR",t[t.INVALID_ENUM=WGL$1.INVALID_ENUM]="INVALID_ENUM",t[t.INVALID_VALUE=WGL$1.INVALID_VALUE]="INVALID_VALUE",t[t.INVALID_OPERATION=WGL$1.INVALID_OPERATION]="INVALID_OPERATION",t[t.INVALID_FRAMEBUFFER_OPERATION=WGL$1.INVALID_FRAMEBUFFER_OPERATION]="INVALID_FRAMEBUFFER_OPERATION",t[t.OUT_OF_MEMORY=WGL$1.OUT_OF_MEMORY]="OUT_OF_MEMORY",t[t.CONTEXT_LOST_WEBGL=WGL$1.CONTEXT_LOST_WEBGL]="CONTEXT_LOST_WEBGL"}(WGL_ERROR||(WGL_ERROR={})),LightGLContext.prototype.MODELVIEW=LightGLContext.MODELVIEW,LightGLContext.prototype.PROJECTION=LightGLContext.PROJECTION,LightGLContext.prototype.HALF_FLOAT_OES=LightGLContext.HALF_FLOAT_OES;var DRAW_MODES;!function(t){t[t.POINTS=WGL$1.POINTS]="POINTS",t[t.LINES=WGL$1.LINES]="LINES",t[t.LINE_STRIP=WGL$1.LINE_STRIP]="LINE_STRIP",t[t.LINE_LOOP=WGL$1.LINE_LOOP]="LINE_LOOP",t[t.TRIANGLES=WGL$1.TRIANGLES]="TRIANGLES",t[t.TRIANGLE_STRIP=WGL$1.TRIANGLE_STRIP]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=WGL$1.TRIANGLE_FAN]="TRIANGLE_FAN"}(DRAW_MODES||(DRAW_MODES={}));const GL_COLOR_BLACK=[0,0,0,1],SHADER_VAR_TYPES=["FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT"],WGL=WebGLRenderingContext;class Buffer{constructor(t,e){this.target=t,this.type=e,assert(t==WGL.ARRAY_BUFFER||t==WGL.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),assert(e==Float32Array||e==Uint16Array,"type == Float32Array || type == Uint16Array"),this.buffer=void 0,this.type=e,this.data=[],this.count=0,this.spacing=0,this.hasBeenCompiled=!1}compile(t=WGL.STATIC_DRAW,e=currentGL()){assert(WGL.STATIC_DRAW==t||WGL.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),e.handleError(),this.buffer=this.buffer||e.createBuffer(),e.handleError();let r;if(0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof V3)assert(!(this.data[0]instanceof V3)||this.type==Float32Array),V3.pack(this.data,r=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;r=new this.type(t);let e=this.data.length,i=t;for(;e--;){const t=this.data[e];let s=t.length;for(;s--;)r[--i]=t[s]}assert(0==i)}else r=new this.type(this.data);const t=this.data.length?r.length/this.data.length:0;assert(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),NLA_DEBUG&&(1e4<=r.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,r)),assert(0!==t),this.spacing=t,this.count=this.data.length}e.bindBuffer(this.target,this.buffer),e.handleError(),e.bufferData(this.target,r,t),e.handleError(),this.hasBeenCompiled=!0}}class Texture{constructor(t,e,r,i=currentGL()){this.gl=i,r=r||{},this.texture=i.createTexture(),i.handleError(),this.width=t,this.gl=i,this.height=e,this.format=r.format||WGL$1.RGBA,this.type=r.type||WGL$1.UNSIGNED_BYTE;const s=r.filter||r.magFilter||WGL$1.LINEAR,o=r.filter||r.minFilter||WGL$1.LINEAR;if(this.type===WGL$1.FLOAT){if(!i.getExtension("OES_texture_float"))throw new Error("OES_texture_float is required but not supported");if((o!==WGL$1.NEAREST||s!==WGL$1.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===LightGLContext.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw new Error("OES_texture_half_float is required but not supported");if((o!==WGL$1.NEAREST||s!==WGL$1.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw new Error("OES_texture_half_float_linear is required but not supported")}i.bindTexture(WGL$1.TEXTURE_2D,this.texture),i.pixelStorei(WGL$1.UNPACK_FLIP_Y_WEBGL,1),i.texParameteri(WGL$1.TEXTURE_2D,WGL$1.TEXTURE_MAG_FILTER,s),i.texParameteri(WGL$1.TEXTURE_2D,WGL$1.TEXTURE_MIN_FILTER,o),i.texParameteri(WGL$1.TEXTURE_2D,WGL$1.TEXTURE_WRAP_S,r.wrap||r.wrapS||WGL$1.CLAMP_TO_EDGE),i.texParameteri(WGL$1.TEXTURE_2D,WGL$1.TEXTURE_WRAP_T,r.wrap||r.wrapT||WGL$1.CLAMP_TO_EDGE),i.texImage2D(WGL$1.TEXTURE_2D,0,this.format,t,e,0,this.format,this.type,null)}bind(t=0){this.gl.activeTexture(WGL$1.TEXTURE0+t),this.gl.bindTexture(WGL$1.TEXTURE_2D,this.texture)}unbind(t=0){this.gl.activeTexture(WGL$1.TEXTURE0+t),this.gl.bindTexture(WGL$1.TEXTURE_2D,null)}canDrawTo(){const t=this.gl;this.framebuffer=this.framebuffer||t.createFramebuffer(),t.bindFramebuffer(WGL$1.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(WGL$1.FRAMEBUFFER,WGL$1.COLOR_ATTACHMENT0,WGL$1.TEXTURE_2D,this.texture,0);const e=t.checkFramebufferStatus(WGL$1.FRAMEBUFFER)==WGL$1.FRAMEBUFFER_COMPLETE;return t.bindFramebuffer(WGL$1.FRAMEBUFFER,null),e}drawTo(t){const e=this.gl;if(this.framebuffer=this.framebuffer||e.createFramebuffer(),this.renderbuffer=this.renderbuffer||e.createRenderbuffer(),e.bindFramebuffer(WGL$1.FRAMEBUFFER,this.framebuffer),e.bindRenderbuffer(WGL$1.RENDERBUFFER,this.renderbuffer),this.width==this.renderbuffer.width&&this.height==this.renderbuffer.height||(this.renderbuffer.width=this.width,this.renderbuffer.height=this.height,e.renderbufferStorage(WGL$1.RENDERBUFFER,WGL$1.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(WGL$1.FRAMEBUFFER,WGL$1.COLOR_ATTACHMENT0,WGL$1.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(WGL$1.FRAMEBUFFER,WGL$1.DEPTH_ATTACHMENT,WGL$1.RENDERBUFFER,this.renderbuffer),e.checkFramebufferStatus(WGL$1.FRAMEBUFFER)!=WGL$1.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete this.framebuffer)");e.viewport(0,0,this.width,this.height),t(e),e.bindFramebuffer(WGL$1.FRAMEBUFFER,null),e.bindRenderbuffer(WGL$1.RENDERBUFFER,null);const r=e.getParameter(WGL$1.VIEWPORT);e.viewport(r[0],r[1],r[2],r[3])}swapWith(t){assert(this.gl==t.gl);let e;e=t.texture,t.texture=this.texture,this.texture=e,e=t.width,t.width=this.width,this.width=e,e=t.height,t.height=this.height,this.height=e}static fromImage(t,e,r=currentGL()){e=e||{};const i=new Texture(t.width,t.height,e);try{r.texImage2D(WGL$1.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?new Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):new Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=WGL$1.NEAREST&&e.minFilter!=WGL$1.LINEAR&&r.generateMipmap(WGL$1.TEXTURE_2D),i}static fromURL(t,e,r=currentGL()){Texture.checkerBoardCanvas=Texture.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=Texture.fromImage(Texture.checkerBoardCanvas,e),s=new Image;return s.onload=(()=>Texture.fromImage(s,e,r).swapWith(i)),s.src=t,i}}export{Buffer,currentGL,WGL$1 as WGL,LightGLContext,pushQuad,hexIntToGLColor,DRAW_MODES,GL_COLOR_BLACK,SHADER_VAR_TYPES,Mesh,Shader,Texture};
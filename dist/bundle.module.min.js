function isArray(t){return Array==t.constructor||Float32Array==t.constructor||Float64Array==t.constructor}function isFloatArray(t){return Float32Array==t.constructor||Float64Array==t.constructor||Array.isArray(t)&&t.every(t=>"number"==typeof t)}function isIntArray(t){return!![Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].some(e=>t instanceof e)||(t instanceof Float32Array||t instanceof Float64Array||Array.isArray(t))&&t.every(t=>Number.isInteger(t))}function currentGL(){return LightGLContext.gl}function isNumber(t){const e=Object.prototype.toString.call(t);return"[object Number]"==e||"[object Boolean]"==e}function pushQuad(t,e,r,i,s,n){e?t.push(r,s,i,i,s,n):t.push(r,i,s,i,n,s)}function hexIntToGLColor(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}import{AABB,DEG,M4,NLA_DEBUG,NLA_PRECISION,P3ZX,Transformable,V,V3,addOwnProperties,arrayFromFunction,assert,assertInst,assertVectors,assertf,lerp}from"ts3dutils";import chroma from"chroma-js";var __awaiter=function(t,e,r,i){return new(r||(r=Promise))(function(s,n){function o(t){try{h(i.next(t))}catch(t){n(t)}}function a(t){try{h(i.throw(t))}catch(t){n(t)}}function h(t){t.done?s(t.value):new r(function(e){e(t.value)}).then(o,a)}h((i=i.apply(t,e||[])).next())})};const{cos:cos,sin:sin,PI:PI,min:min,max:max}=Math,WGL$2=WebGLRenderingContext;class Mesh extends Transformable{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","LGL_Vertex")}calcVolume(){let t=0,e=V3.O,r=0;const i=this.TRIANGLES,s=this.vertices;for(let n=0;n<i.length;n+=3){const o=i[n+0],a=i[n+1],h=i[n+2],c=s[o],l=s[a],u=s[h],f=l.minus(c),d=u.minus(c),m=f.cross(d),E=c.plus(l.plus(u)).div(3);t+=E.z*m.z/2,r+=m.length(),e=e.plus(new V3(E.x,E.y,E.z/2).times(E.z*m.z/2))}return{volume:t,centroid:e.div(i.length/3),area:r/2}}addVertexBuffer(t,e){return assert(!this.vertexBuffers[e],"Buffer "+e+" already exists."),this.hasBeenCompiled=!1,assert("string"==typeof t),assert("string"==typeof e),(this.vertexBuffers[e]=new Buffer(WGL$2.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t){return this.hasBeenCompiled=!1,(this.indexBuffers[t]=new Buffer(WGL$2.ELEMENT_ARRAY_BUFFER,Uint16Array)).name=t,this[t]=[],this}concat(...t){const e=new Mesh;return[this].concat(t).forEach(t=>{const r=e.vertices?e.vertices.length:0;Object.getOwnPropertyNames(t.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r].name;e.vertexBuffers[r]||e.addVertexBuffer(i,r),e[i].push(t[i])}),Object.getOwnPropertyNames(t.indexBuffers).forEach(i=>{e.indexBuffers[i]||e.addIndexBuffer(i),e[i].push(...t[i].map(t=>t+r))})}),e}compile(t=currentGL()){Object.getOwnPropertyNames(this.vertexBuffers).forEach(t=>{const e=this.vertexBuffers[t];e.data=this[e.name],e.compile()});for(const e in this.indexBuffers){const r=this.indexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}return this.hasBeenCompiled=!0,this}static fromBinarySTL(t){return __awaiter(this,void 0,void 0,function*(){return new Promise((e,r)=>{const i=(new Mesh).addVertexBuffer("normals","LGL_Normal"),s=new FileReader;s.onerror=r,s.onload=function(t){function r(){const t=s.getFloat32(a,!0);a+=4;const e=s.getFloat32(a,!0);a+=4;const r=s.getFloat32(a,!0);return a+=4,new V3(t,e,r)}const s=new DataView(this.result),n=s.getUint32(80,!0);i.normals.length=3*n,i.vertices.length=3*n;let o=3*n,a=84;for(;o;){o-=3;const t=r();i.normals[o+0]=t,i.normals[o+1]=t,i.normals[o+2]=t,i.vertices[o+0]=r(),i.vertices[o+1]=r(),i.vertices[o+2]=r(),a+=2}e(i)},s.readAsArrayBuffer(t)})})}toBinarySTL(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const t=this.TRIANGLES,e=t.length/3,r=new ArrayBuffer(84+50*e),i=new DataView(r);i.setUint32(80,e,!0);let s=84,n=t.length;for(;n;){n-=3;const e=this.vertices[t[n]],r=this.vertices[t[n+1]],o=this.vertices[t[n+2]];[V3.normalOnPoints(e,r,o),e,r,o].forEach(t=>{i.setFloat32(s,t.x,!0),s+=4,i.setFloat32(s,t.y,!0),s+=4,i.setFloat32(s,t.z,!0),s+=4}),s+=2}return assert(s==r.byteLength,s+" "+r.byteLength),new Blob([r],{type:"application/octet-stream"})}transform(t){const e=new Mesh;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","LGL_Normal");const r=t.as3x3().inversed().transposed().normalized();e.normals=this.normals.map(t=>r.transformVector(t).unit())}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];return e.compile(),e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","LGL_Normal");const t=this.TRIANGLES,e=this.vertices,r=this.normals;r.length=e.length;for(let i=0;i<t.length;i+=3){const s=t[i],n=t[i+1],o=t[i+2],a=e[s],h=e[n],c=e[o],l=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s].plus(l),r[n]=r[n].plus(l),r[o]=r[o].plus(l)}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this.hasBeenCompiled=!1,this}computeWireframeFromFlatTriangles(t="LINES"){function e(t,e){return min(t,e)<<16|max(t,e)}if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const r=new Set,i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)r.add(e(i[t+0],i[t+1])),r.add(e(i[t+1],i[t+2])),r.add(e(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),r.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(t="LINES"){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const e=this.TRIANGLES;this[t]||this.addIndexBuffer(t);const r=this[t];for(let t=0;t<e.length;t+=3)e[t+0]<e[t+1]&&r.push(e[t+0],e[t+1]),e[t+1]<e[t+2]&&r.push(e[t+1],e[t+2]),e[t+2]<e[t+0]&&r.push(e[t+2],e[t+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.normals)throw new Error("normals must be defined.");const r=this.vertices,i=this.vertices.length;this[e]||this.addIndexBuffer(e);for(let s=0;s<this.normals.length;s++)r[i+s]=r[s].plus(this.normals[s].toLength(t)),this[e].push(i+s,s);return this.hasBeenCompiled=!1,this}getAABB(){return(new AABB).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const e=t.detailX||t.detail||1,r=t.detailY||t.detail||1,i=t.startX||0,s=t.startY||0,n=t.width||1,o=t.height||1,a=(new Mesh).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal").addVertexBuffer("coords","LGL_TexCoord");for(let t=0;t<=r;t++){const h=t/r;for(let c=0;c<=e;c++){const l=c/e;if(a.vertices.push(new V3(i+l*n,s+h*o,0)),a.coords.push([l,h]),a.normals.push(V3.Z),c<e&&t<r){const r=c+t*(e+1);a.TRIANGLES.push(r,r+e+1,r+1,r+e+1,r+e+2,r+1)}}}for(let t=0;t<e;t++)a.LINES.push(t,t+1),a.LINES.push((e+1)*r+t,(e+1)*r+t+1);for(let t=0;t<r;t++)a.LINES.push(e*t,e*(t+1)+1),a.LINES.push(e*(t+1),e*(t+2)+1);return a.compile(),a}static cube(){const t=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e=[0,1,2,3,4,5,6,7,0,4,1,5,2,6,3,7,2,6,0,4,3,7,1,5];t.vertices=e.map(t=>Mesh.UNIT_CUBE_CORNERS[t]),t.normals=[V3.X.negated(),V3.X,V3.Y.negated(),V3.Y,V3.Z.negated(),V3.Z].map(t=>[t,t,t,t]).concatenated();for(let r=0;r<24;r+=4)pushQuad(t.TRIANGLES,0!=r%8,e[r],e[r+1],e[r+2],e[r+3]);return t.LINES=[0,1,0,2,1,3,2,3,0,4,1,5,2,6,3,7,4,5,4,6,5,7,6,7].map(t=>e.indexOf(t)),t.compile(),t}static isocahedron(){return Mesh.sphere(0)}static sphere2(t,e){const r=arrayFromFunction(t,e=>{const r=e/(t-1)*PI-PI/2;return new V3(0,cos(r),sin(r))});return Mesh.rotation(r,{anchor:V3.O,dir1:V3.Z},2*PI,e,!0,r)}static sphere(t=3){function e(t,r,i,s,n,o,a,h,c,l){if(0==s)o.push(a,h,c),a<h&&l.push(a,h),h<c&&l.push(h,c),c<a&&l.push(c,a);else{const u=t.plus(r).toLength(1),f=r.plus(i).toLength(1),d=i.plus(t).toLength(1),m=n.length,E=m+1,L=m+2;n.push(u,f,d),e(u,f,d,s-1,n,o,m,E,L,l),e(t,u,d,s-1,n,o,a,m,L,l),e(r,f,u,s-1,n,o,h,E,m,l),e(i,d,f,s-1,n,o,c,L,E,l)}}const r=(1+Math.sqrt(5))/2,i=new V3(1,r,0).unit(),s=i.x,n=i.y,o=[new V3(-s,n,0),new V3(s,n,0),new V3(-s,-n,0),new V3(s,-n,0),new V3(0,-s,n),new V3(0,s,n),new V3(0,-s,-n),new V3(0,s,-n),new V3(n,0,-s),new V3(n,0,s),new V3(-n,0,-s),new V3(-n,0,s)],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],h=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");h.vertices.push(...o),t=void 0==t?4:t;for(let r=0;r<20;r++){const[i,s,n]=a.slice(3*r,3*r+3);e(o[i],o[s],o[n],t,h.vertices,h.TRIANGLES,i,s,n,h.LINES)}return h.normals=h.vertices,h.compile(),h}static aabb(t){const e=M4.multiplyMultiple(M4.translate(t.min),M4.scale(t.size().max(new V3(NLA_PRECISION,NLA_PRECISION,NLA_PRECISION)))),r=Mesh.cube().transform(e);return r.computeNormalLines(20),r.compile(),r}static offsetVertices(t,e,r,i){assertVectors.apply(void 0,t),assertVectors(e);const s=(new Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","LGL_TexCoord");i&&s.addVertexBuffer("normals","LGL_Normal"),s.vertices=t.concat(t.map(t=>t.plus(e)));const n=t.length;s.coords=arrayFromFunction(2*n,t=>[t%n/n,t/n|0]);const o=s.TRIANGLES;for(let e=0;e<t.length-1;e++)pushQuad(o,!1,e,e+1,t.length+e,t.length+e+1);return r&&pushQuad(o,!1,0,t.length-1,t.length,2*t.length-1),i&&(s.normals=i.concat(i)),s.compile(),s}static rotation(t,e,r,i,s=!0,n){const o=(new Mesh).addIndexBuffer("TRIANGLES");n&&o.addVertexBuffer("normals","LGL_Normal");const a=t.length,h=a*i,c=new M4,l=o.TRIANGLES;for(let u=0;u<i;u++){const f=r/i*u;if(M4.rotateLine(e.anchor,e.dir1,f,c),o.vertices.push(...c.transformedPoints(t)),n&&o.normals.push(...c.transformedVectors(n)),s||u!==i-1)for(let t=0;t<a-1;t++)pushQuad(l,!1,u*a+t+1,u*a+t,((u+1)*a+t+1)%h,((u+1)*a+t)%h)}return o.compile(),o}static parametric(t,e,r,i,s,n,o,a){const h=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES");for(let c=0;c<=o;c++){const l=lerp(r,i,c/o);for(let r=0;r<=a;r++){const i=lerp(s,n,r/a);if(h.vertices.push(t(l,i)),h.normals.push(e(l,i)),r<a&&c<o){const t=r+c*(a+1);pushQuad(h.TRIANGLES,!1,t,t+a+1,t+1,t+a+2)}}}return h.compile(),h}static load(t){const e=new Mesh;if(!Array.isArray(t.vertices[0]))throw new Error;return e.vertices=t.vertices.map(t=>V(t)),t.triangles&&(e.addIndexBuffer("TRIANGLES"),e.TRIANGLES=t.triangles),t.normals&&(e.addVertexBuffer("normals","LGL_Normal"),e.normals=t.normals),e.compile(),e}}Mesh.UNIT_CUBE_CORNERS=[V3.O,new V3(0,0,1),new V3(0,1,0),new V3(0,1,1),new V3(1,0,0),new V3(1,0,1),new V3(1,1,0),V3.XYZ];const WGL$3=WebGLRenderingContext;var DRAW_MODES;!function(t){t[t.POINTS=WGL$3.POINTS]="POINTS",t[t.LINES=WGL$3.LINES]="LINES",t[t.LINE_STRIP=WGL$3.LINE_STRIP]="LINE_STRIP",t[t.LINE_LOOP=WGL$3.LINE_LOOP]="LINE_LOOP",t[t.TRIANGLES=WGL$3.TRIANGLES]="TRIANGLES",t[t.TRIANGLE_STRIP=WGL$3.TRIANGLE_STRIP]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=WGL$3.TRIANGLE_FAN]="TRIANGLE_FAN"}(DRAW_MODES||(DRAW_MODES={}));const SHADER_VAR_TYPES=["FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT"],DRAW_MODE_CHECKS={[DRAW_MODES.POINTS]:t=>!0,[DRAW_MODES.LINES]:t=>0==t%2,[DRAW_MODES.LINE_STRIP]:t=>t>2,[DRAW_MODES.LINE_LOOP]:t=>t>2,[DRAW_MODES.TRIANGLES]:t=>0==t%3,[DRAW_MODES.TRIANGLE_STRIP]:t=>t>3,[DRAW_MODES.TRIANGLE_FAN]:t=>t>3};class Shader{constructor(t,e,r=currentGL()){function i(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,WGL$3.COMPILE_STATUS))throw new Error("compile error: "+r.getShaderInfoLog(i));return i}this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1;const s=`\n\t\tuniform mat3 LGL_NormalMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrix;\n\t\tuniform mat4 LGL_ProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrixInverse;\n\t\tuniform mat4 LGL_ProjectionMatrixInverse;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrixInverse;\n\t`,n=s+`\n\t\tattribute vec4 LGL_Vertex;\n\t\tattribute vec2 LGL_TexCoord;\n\t\tattribute vec3 LGL_Normal;\n\t\tattribute vec4 LGL_Color;\n\t`,o=`  precision highp float;`+s,a=s.match(/\bLGL_\w+/g);this.gl=r;const h=r.createProgram();if(h||r.handleError(),this.program=h,r.attachShader(this.program,i(WGL$3.VERTEX_SHADER,n+t)),r.attachShader(this.program,i(WGL$3.FRAGMENT_SHADER,o+e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,WGL$3.LINK_STATUS))throw new Error("link error: "+r.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={},this.activeMatrices={},a&&a.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,WGL$3.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}r.handleError()}static create(t,e){return new Shader(t,e)}uniforms(t){const e=this.gl;e.useProgram(this.program),e.handleError();for(const r in t){const i=this.uniformLocations[r]||e.getUniformLocation(this.program,r);if(!i&&console.warn(r+" uniform is not used in shader"),!i)continue;this.uniformLocations[r]=i;let s=t[r];const n=this.uniformInfos[r];if(NLA_DEBUG&&(e.SAMPLER_2D!=n.type&&e.SAMPLER_CUBE!=n.type&&e.INT!=n.type||(1==n.size?assert(Number.isInteger(s)):assert(isIntArray(s)&&s.length==n.size,"value must be int array if info.size != 1")),assert(e.FLOAT!=n.type||1==n.size&&"number"==typeof s||isFloatArray(s)&&n.size==s.length),assert(e.FLOAT_VEC3!=n.type||1==n.size&&s instanceof V3||Array.isArray(s)&&n.size==s.length&&assertVectors(...s)),assert(e.FLOAT_VEC4!=n.type||1!=n.size||isFloatArray(s)&&4==s.length),assert(e.FLOAT_MAT4!=n.type||s instanceof M4,()=>s.toSource()),assert(e.FLOAT_MAT3!=n.type||9==s.length||s instanceof M4)),s instanceof V3&&(s=s.toArray()),e.FLOAT_VEC4==n.type&&1!=n.size)e.uniform4fv(i,s.concatenated());else if(s.length)switch(s.length){case 1:e.uniform1fv(i,s);break;case 2:e.uniform2fv(i,s);break;case 3:e.uniform3fv(i,s);break;case 4:e.uniform4fv(i,s);break;case 9:e.uniformMatrix3fv(i,!1,new Float32Array([s[0],s[3],s[6],s[1],s[4],s[7],s[2],s[5],s[8]]));break;case 16:e.uniformMatrix4fv(i,!1,new Float32Array([s[0],s[4],s[8],s[12],s[1],s[5],s[9],s[13],s[2],s[6],s[10],s[14],s[3],s[7],s[11],s[15]]));break;default:throw new Error("don't know how to load uniform \""+r+'" of length '+s.length)}else if("number"==typeof s)e.SAMPLER_2D==n.type||e.SAMPLER_CUBE==n.type||e.INT==n.type?e.uniform1i(i,s):e.uniform1f(i,s);else if("boolean"==typeof s)e.uniform1i(i,+s);else{if(!(s instanceof M4))throw new Error('attempted to set uniform "'+r+'" to invalid value '+s);{const t=s.m;if(e.FLOAT_MAT4==n.type)e.uniformMatrix4fv(i,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(e.FLOAT_MAT3==n.type)e.uniformMatrix3fv(i,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(e.FLOAT_MAT2!=n.type)throw new Error(`Can't assign M4 to ${n.type}`);e.uniformMatrix2fv(i,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}e.handleError()}return this}draw(t,e=DRAW_MODES.TRIANGLES,r,i){assert(t.hasBeenCompiled,"mesh.hasBeenCompiled"),assert(void 0!=DRAW_MODES[e]);const s=DRAW_MODES[e];return this.drawBuffers(t.vertexBuffers,t.indexBuffers[s],e,r,i)}drawBuffers(t,e,r=DRAW_MODES.TRIANGLES,i=0,s){const n=this.gl;n.handleError(),assert(void 0!=DRAW_MODES[r]),assertf(()=>1<=Object.keys(t).length),Object.keys(t).forEach(e=>assertInst(Buffer,t[e]));const o=this.activeMatrices,a=(o.LGL_ModelViewMatrixInverse||o.LGL_NormalMatrix)&&n.modelViewMatrix.inversed(),h=o.LGL_ProjectionMatrixInverse&&n.projectionMatrix.inversed(),c=(o.LGL_ModelViewProjectionMatrix||o.LGL_ModelViewProjectionMatrixInverse)&&n.projectionMatrix.times(n.modelViewMatrix),l={};o.LGL_ModelViewMatrix&&this.modelViewMatrixVersion!=n.modelViewMatrixVersion&&(l.LGL_ModelViewMatrix=n.modelViewMatrix),o.LGL_ModelViewMatrixInverse&&(l.LGL_ModelViewMatrixInverse=a),o.LGL_ProjectionMatrix&&this.projectionMatrixVersion!=n.projectionMatrixVersion&&(l.LGL_ProjectionMatrix=n.projectionMatrix),h&&(l.LGL_ProjectionMatrixInverse=h),c&&(l.LGL_ModelViewProjectionMatrix=c),c&&o.LGL_ModelViewProjectionMatrixInverse&&(l.LGL_ModelViewProjectionMatrixInverse=c.inversed()),o.LGL_NormalMatrix&&this.modelViewMatrixVersion!=n.modelViewMatrixVersion&&(l.LGL_NormalMatrix=a.transposed()),this.uniforms(l),this.projectionMatrixVersion=n.projectionMatrixVersion,this.modelViewMatrixVersion=n.modelViewMatrixVersion;let u=1/0;for(const e in t){const r=t[e];assert(r.hasBeenCompiled);const i=this.attributes[e]||n.getAttribLocation(this.program,e);n.handleError(),-1!=i&&r.buffer&&(this.attributes[e]=i,n.bindBuffer(WGL$3.ARRAY_BUFFER,r.buffer),n.handleError(),n.enableVertexAttribArray(i),n.handleError(),n.vertexAttribPointer(i,r.spacing,WGL$3.FLOAT,!1,0,0),n.handleError(),u=Math.min(u,r.count))}for(const e in this.attributes)e in t||(n.disableVertexAttribArray(this.attributes[e]),n.handleError());if(u){if(s=s||(e?e.count:u),assert(DRAW_MODE_CHECKS[r](s),"count "+s+" doesn't fulfill requirement "+DRAW_MODE_CHECKS[r].toString()+" for mode "+DRAW_MODES[r]),e){if(assert(e.hasBeenCompiled),assert(u>e.maxValue),assert(s%e.spacing==0),assert(i%e.spacing==0),i+s>e.count)throw new Error("Buffer not long enough for passed parameters start/length/buffer length "+i+" "+s+" "+e.count);n.bindBuffer(WGL$3.ELEMENT_ARRAY_BUFFER,e.buffer),n.handleError(),n.drawElements(r,s,WGL$3.UNSIGNED_SHORT,2*i),n.handleError()}else{if(i+s>u)throw new Error("invalid");n.drawArrays(r,i,s),n.handleError()}n.drawCallCount++}return this}}const GL_COLOR_BLACK=[0,0,0,1],WGL$1=WebGLRenderingContext;class LightGLContext extends Object{constructor(t){super(),this.modelViewMatrix=new M4,this.projectionMatrix=new M4,this.MODELVIEW=LightGLContext.MODELVIEW,this.PROJECTION=LightGLContext.PROJECTION,this.tempMatrix=new M4,this.resultMatrix=new M4,this.modelViewStack=[],this.projectionStack=[],this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.immediate={mesh:(new Mesh).addVertexBuffer("coords","LGL_TexCoord").addVertexBuffer("colors","LGL_Color"),mode:-1,coord:[0,0],color:[1,1,1,1],pointSize:1,shader:new Shader(`\n            uniform float pointSize;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                color = LGL_Color;\n                coord = LGL_TexCoord;\n                gl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n                gl_PointSize = pointSize;\n            }\n        `,`\n            uniform sampler2D texture;\n            uniform float pointSize;\n            uniform bool useTexture;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                gl_FragColor = color;\n                if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n            }\n        `)},this.matrixMode(LightGLContext.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw new Error("invalid matrix mode "+t)}}loadIdentity(){M4.identity(this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}loadMatrix(t){M4.copy(t,this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}multMatrix(t){M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const e=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=e,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(M4.mirror(t))}perspective(t,e,r,i,s){this.multMatrix(M4.perspectiveRad(t*DEG,e,r,i,this.tempMatrix))}frustum(t,e,r,i,s,n){this.multMatrix(M4.frustum(t,e,r,i,s,n,this.tempMatrix))}ortho(t,e,r,i,s,n){this.multMatrix(M4.ortho(t,e,r,i,s,n,this.tempMatrix))}scale(...t){this.multMatrix(M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(M4.mirror(P3ZX))}translate(t,e,r){void 0!==e?this.multMatrix(M4.translate(t,e,r,this.tempMatrix)):this.multMatrix(M4.translate(t,this.tempMatrix))}rotate(t,e,r,i){this.multMatrix(M4.rotate(t*DEG,{x:e,y:r,z:i},this.tempMatrix))}lookAt(t,e,r){this.multMatrix(M4.lookAt(t,e,r,this.tempMatrix))}pushMatrix(){this.stack.push(M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();assert(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[e,r,i,s]=t,n=new M4([i/2,0,0,e+i/2,s/2,0,0,r+s/2,0,0,1,0,0,0,0,1]);return M4.multiplyMultiple(n,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?hexIntToGLColor(t[0]):1==t.length&&"string"==typeof t[0]?chroma(t[0]).gl():[t[0],t[1],t[2],t[3]||0]}texCoord(...t){this.immediate.coord=V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!LightGLContext.gl.getParameter(WGL$1.TEXTURE_BINDING_2D)}).drawBuffers(this.immediate.mesh.vertexBuffers,void 0,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){LightGLContext.gl=this}animate(t){const e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let r=performance.now(),i=!0;const s=n=>{const o=performance.now();t.call(this,o,o-r),r=o,i&&e(s)};return e(s),()=>{i=!1}}fullscreen(t={}){function e(){o.canvas.width=window.innerWidth-i-s,o.canvas.height=window.innerHeight-r-n,o.viewport(0,0,o.canvas.width,o.canvas.height),t.camera&&(o.matrixMode(LightGLContext.PROJECTION),o.loadIdentity(),o.perspective(t.fov||45,o.canvas.width/o.canvas.height,t.near||.1,t.far||1e3),o.matrixMode(LightGLContext.MODELVIEW))}const r=t.paddingTop||0,i=t.paddingLeft||0,s=t.paddingRight||0,n=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");document.body.appendChild(this.canvas),document.body.style.overflow="hidden",this.canvas.style.position="absolute",this.canvas.style.left=i+"px",this.canvas.style.top=r+"px";const o=this;return window.addEventListener("resize",e),e(),this}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}handleError(){const t=this.getError();if(0!==t)throw new Error(""+t+WGL_ERROR[t])}static create(t={}){const e=t.canvas||document.createElement("canvas");t.canvas||(e.width=800,e.height=600),"alpha"in t||(t.alpha=!1);let r=void 0;try{r=e.getContext("webgl",t),console.log("getting context")}catch(t){console.log(t,r)}try{r=r||e.getContext("experimental-webgl",t)}catch(t){console.log(t,r)}if(!r)throw new Error("WebGL not supported");return LightGLContext.gl=r,addOwnProperties(r,LightGLContext.prototype),addOwnProperties(r,new LightGLContext(r)),r}}LightGLContext.MODELVIEW=0,LightGLContext.PROJECTION=1,LightGLContext.HALF_FLOAT_OES=36193;var WGL_ERROR;!function(t){t[t.NO_ERROR=WGL$1.NO_ERROR]="NO_ERROR",t[t.INVALID_ENUM=WGL$1.INVALID_ENUM]="INVALID_ENUM",t[t.INVALID_VALUE=WGL$1.INVALID_VALUE]="INVALID_VALUE",t[t.INVALID_OPERATION=WGL$1.INVALID_OPERATION]="INVALID_OPERATION",t[t.INVALID_FRAMEBUFFER_OPERATION=WGL$1.INVALID_FRAMEBUFFER_OPERATION]="INVALID_FRAMEBUFFER_OPERATION",t[t.OUT_OF_MEMORY=WGL$1.OUT_OF_MEMORY]="OUT_OF_MEMORY",t[t.CONTEXT_LOST_WEBGL=WGL$1.CONTEXT_LOST_WEBGL]="CONTEXT_LOST_WEBGL"}(WGL_ERROR||(WGL_ERROR={})),LightGLContext.prototype.MODELVIEW=LightGLContext.MODELVIEW,LightGLContext.prototype.PROJECTION=LightGLContext.PROJECTION,LightGLContext.prototype.HALF_FLOAT_OES=LightGLContext.HALF_FLOAT_OES;const WGL=WebGLRenderingContext;class Buffer{constructor(t,e){this.target=t,this.type=e,assert(t==WGL.ARRAY_BUFFER||t==WGL.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),assert(e==Float32Array||e==Uint16Array,"type == Float32Array || type == Uint16Array"),this.buffer=void 0,this.type=e,this.data=[],this.count=0,this.spacing=0,this.hasBeenCompiled=!1}compile(t=WGL.STATIC_DRAW,e=currentGL()){assert(WGL.STATIC_DRAW==t||WGL.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),e.handleError(),this.buffer=this.buffer||e.createBuffer(),e.handleError();let r;if(0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof V3)assert(!(this.data[0]instanceof V3)||this.type==Float32Array),V3.pack(this.data,r=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;r=new this.type(t);let e=this.data.length,i=t;for(;e--;){const t=this.data[e];let s=t.length;for(;s--;)r[--i]=t[s]}assert(0==i)}else r=new this.type(this.data);const t=this.data.length?r.length/this.data.length:0;assert(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),NLA_DEBUG&&(1e4<=r.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,r)),assert(0!==t),this.spacing=t,this.count=this.data.length}e.bindBuffer(this.target,this.buffer),e.handleError(),e.bufferData(this.target,r,t),e.handleError(),this.hasBeenCompiled=!0}}class Texture{constructor(t,e,r={},i=currentGL()){this.gl=i,this.texture=i.createTexture(),i.handleError(),this.width=t,this.height=e,this.format=r.format||i.RGBA,this.type=r.type||i.UNSIGNED_BYTE;const s=r.filter||r.magFilter||i.LINEAR,n=r.filter||r.minFilter||i.LINEAR;if(this.type===i.FLOAT){if(!i.getExtension("OES_texture_float"))throw new Error("OES_texture_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===LightGLContext.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw new Error("OES_texture_half_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw new Error("OES_texture_half_float_linear is required but not supported")}i.bindTexture(i.TEXTURE_2D,this.texture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,r.wrap||r.wrapS||i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,r.wrap||r.wrapT||i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,this.format,t,e,0,this.format,this.type,null)}bind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}unbind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}canDrawTo(){const t=this.gl;this.framebuffer=this.framebuffer||t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0);const e=t.checkFramebufferStatus(t.FRAMEBUFFER)==t.FRAMEBUFFER_COMPLETE;return t.bindFramebuffer(t.FRAMEBUFFER,null),e}drawTo(t){const e=this.gl;if(this.framebuffer=this.framebuffer||e.createFramebuffer(),this.renderbuffer=this.renderbuffer||e.createRenderbuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.bindRenderbuffer(e.RENDERBUFFER,this.renderbuffer),this.width==this.renderbuffer.width&&this.height==this.renderbuffer.height||(this.renderbuffer.width=this.width,this.renderbuffer.height=this.height,e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.renderbuffer),e.checkFramebufferStatus(e.FRAMEBUFFER)!=e.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete this.framebuffer)");const r=e.getParameter(e.VIEWPORT);e.viewport(0,0,this.width,this.height),t(e),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.viewport(r[0],r[1],r[2],r[3])}swapWith(t){assert(this.gl==t.gl);let e;e=t.texture,t.texture=this.texture,this.texture=e,e=t.width,t.width=this.width,this.width=e,e=t.height,t.height=this.height,this.height=e}static fromImage(t,e,r=currentGL()){e=e||{};const i=new Texture(t.width,t.height,e);try{r.texImage2D(r.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?new Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):new Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=r.NEAREST&&e.minFilter!=r.LINEAR&&r.generateMipmap(r.TEXTURE_2D),i}static fromURL(t,e={},r=currentGL()){Texture.checkerBoardCanvas=Texture.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=Texture.fromImage(Texture.checkerBoardCanvas,e),s=new Image;return s.onload=(()=>Texture.fromImage(s,e,r).swapWith(i)),s.src=t,i}}export{Buffer,Mesh,DRAW_MODES,SHADER_VAR_TYPES,isArray,Shader,Texture,GL_COLOR_BLACK,currentGL,isNumber,LightGLContext,pushQuad};
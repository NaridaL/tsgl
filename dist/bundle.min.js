!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("ts3dutils"),require("chroma-js")):"function"==typeof define&&define.amd?define(["exports","ts3dutils","chroma-js"],e):e(t.nla={},t.ts3dutils,t.chroma)}(this,function(t,e,r){"use strict";function i(t){return Float32Array==t.constructor||Float64Array==t.constructor||Array.isArray(t)&&t.every(t=>"number"==typeof t)}function s(t){return!![Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].some(e=>t instanceof e)||(t instanceof Float32Array||t instanceof Float64Array||Array.isArray(t))&&t.every(t=>Number.isInteger(t))}function n(){return g.gl}function o(t,e,r,i,s,n){e?t.push(r,s,i,i,s,n):t.push(r,i,s,i,n,s)}function a(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}r=r&&r.hasOwnProperty("default")?r.default:r;var h=function(t,e,r,i){return new(r||(r=Promise))(function(s,n){function o(t){try{h(i.next(t))}catch(t){n(t)}}function a(t){try{h(i.throw(t))}catch(t){n(t)}}function h(t){t.done?s(t.value):new r(function(e){e(t.value)}).then(o,a)}h((i=i.apply(t,e||[])).next())})};const{cos:c,sin:l,PI:f,min:d,max:u}=Math,m=WebGLRenderingContext;class E extends e.Transformable{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","LGL_Vertex")}calcVolume(){let t=0,r=e.V3.O,i=0;const s=this.TRIANGLES,n=this.vertices;for(let o=0;o<s.length;o+=3){const a=s[o+0],h=s[o+1],c=s[o+2],l=n[a],f=n[h],d=n[c],u=f.minus(l),m=d.minus(l),E=u.cross(m),p=l.plus(f.plus(d)).div(3);t+=p.z*E.z/2,i+=E.length(),r=r.plus(new e.V3(p.x,p.y,p.z/2).times(p.z*E.z/2))}return{volume:t,centroid:r.div(s.length/3),area:i/2}}addVertexBuffer(t,r){return e.assert(!this.vertexBuffers[r],"Buffer "+r+" already exists."),this.hasBeenCompiled=!1,e.assert("string"==typeof t),e.assert("string"==typeof r),(this.vertexBuffers[r]=new T(m.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t){return this.hasBeenCompiled=!1,(this.indexBuffers[t]=new T(m.ELEMENT_ARRAY_BUFFER,Uint16Array)).name=t,this[t]=[],this}concat(...t){const e=new E;return[this].concat(t).forEach(t=>{const r=e.vertices?e.vertices.length:0;Object.getOwnPropertyNames(t.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r].name;e.vertexBuffers[r]||e.addVertexBuffer(i,r),e[i].push(t[i])}),Object.getOwnPropertyNames(t.indexBuffers).forEach(i=>{e.indexBuffers[i]||e.addIndexBuffer(i),e[i].push(...t[i].map(t=>t+r))})}),e}compile(t=n()){Object.getOwnPropertyNames(this.vertexBuffers).forEach(t=>{const e=this.vertexBuffers[t];e.data=this[e.name],e.compile()});for(const e in this.indexBuffers){const r=this.indexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}return this.hasBeenCompiled=!0,this}static fromBinarySTL(t){return h(this,void 0,void 0,function*(){return new Promise((r,i)=>{const s=(new E).addVertexBuffer("normals","LGL_Normal"),n=new FileReader;n.onerror=i,n.onload=function(t){function i(){const t=n.getFloat32(h,!0);h+=4;const r=n.getFloat32(h,!0);h+=4;const i=n.getFloat32(h,!0);return h+=4,new e.V3(t,r,i)}const n=new DataView(this.result),o=n.getUint32(80,!0);s.normals.length=3*o,s.vertices.length=3*o;let a=3*o,h=84;for(;a;){a-=3;const t=i();s.normals[a+0]=t,s.normals[a+1]=t,s.normals[a+2]=t,s.vertices[a+0]=i(),s.vertices[a+1]=i(),s.vertices[a+2]=i(),h+=2}r(s)},n.readAsArrayBuffer(t)})})}toBinarySTL(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const t=this.TRIANGLES,r=t.length/3,i=new ArrayBuffer(84+50*r),s=new DataView(i);s.setUint32(80,r,!0);let n=84,o=t.length;for(;o;){o-=3;const r=this.vertices[t[o]],i=this.vertices[t[o+1]],a=this.vertices[t[o+2]];[e.V3.normalOnPoints(r,i,a),r,i,a].forEach(t=>{s.setFloat32(n,t.x,!0),n+=4,s.setFloat32(n,t.y,!0),n+=4,s.setFloat32(n,t.z,!0),n+=4}),n+=2}return e.assert(n==i.byteLength,n+" "+i.byteLength),new Blob([i],{type:"application/octet-stream"})}transform(t){const e=new E;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","LGL_Normal");const r=t.as3x3().inversed().transposed().normalized();e.normals=this.normals.map(t=>r.transformVector(t).unit())}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];return e.compile(),e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","LGL_Normal");const t=this.TRIANGLES,e=this.vertices,r=this.normals;r.length=e.length;for(let i=0;i<t.length;i+=3){const s=t[i],n=t[i+1],o=t[i+2],a=e[s],h=e[n],c=e[o],l=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s].plus(l),r[n]=r[n].plus(l),r[o]=r[o].plus(l)}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this.hasBeenCompiled=!1,this}computeWireframeFromFlatTriangles(t="LINES"){function e(t,e){return d(t,e)<<16|u(t,e)}if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const r=new Set,i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)r.add(e(i[t+0],i[t+1])),r.add(e(i[t+1],i[t+2])),r.add(e(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),r.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(t="LINES"){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const e=this.TRIANGLES;this[t]||this.addIndexBuffer(t);const r=this[t];for(let t=0;t<e.length;t+=3)e[t+0]<e[t+1]&&r.push(e[t+0],e[t+1]),e[t+1]<e[t+2]&&r.push(e[t+1],e[t+2]),e[t+2]<e[t+0]&&r.push(e[t+2],e[t+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.normals)throw new Error("normals must be defined.");const r=this.vertices,i=this.vertices.length;this[e]||this.addIndexBuffer(e);for(let s=0;s<this.normals.length;s++)r[i+s]=r[s].plus(this.normals[s].toLength(t)),this[e].push(i+s,s);return this.hasBeenCompiled=!1,this}getAABB(){return(new e.AABB).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const r=t.detailX||t.detail||1,i=t.detailY||t.detail||1,s=t.startX||0,n=t.startY||0,o=t.width||1,a=t.height||1,h=(new E).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal").addVertexBuffer("coords","LGL_TexCoord");for(let t=0;t<=i;t++){const c=t/i;for(let l=0;l<=r;l++){const f=l/r;if(h.vertices.push(new e.V3(s+f*o,n+c*a,0)),h.coords.push([f,c]),h.normals.push(e.V3.Z),l<r&&t<i){const e=l+t*(r+1);h.TRIANGLES.push(e,e+r+1,e+1,e+r+1,e+r+2,e+1)}}}for(let t=0;t<r;t++)h.LINES.push(t,t+1),h.LINES.push((r+1)*i+t,(r+1)*i+t+1);for(let t=0;t<i;t++)h.LINES.push(r*t,r*(t+1)+1),h.LINES.push(r*(t+1),r*(t+2)+1);return h.compile(),h}static cube(){const t=(new E).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),r=[0,1,2,3,4,5,6,7,0,4,1,5,2,6,3,7,2,6,0,4,3,7,1,5];t.vertices=r.map(t=>E.UNIT_CUBE_CORNERS[t]),t.normals=[e.V3.X.negated(),e.V3.X,e.V3.Y.negated(),e.V3.Y,e.V3.Z.negated(),e.V3.Z].map(t=>[t,t,t,t]).concatenated();for(let e=0;e<24;e+=4)o(t.TRIANGLES,0!=e%8,r[e],r[e+1],r[e+2],r[e+3]);return t.LINES=[0,1,0,2,1,3,2,3,0,4,1,5,2,6,3,7,4,5,4,6,5,7,6,7].map(t=>r.indexOf(t)),t.compile(),t}static isocahedron(){return E.sphere(0)}static sphere2(t,r){const i=e.arrayFromFunction(t,r=>{const i=r/(t-1)*f-f/2;return new e.V3(0,c(i),l(i))});return E.rotation(i,{anchor:e.V3.O,dir1:e.V3.Z},2*f,r,!0,i)}static sphere(t=3){function r(t,e,i,s,n,o,a,h,c,l){if(0==s)o.push(a,h,c),a<h&&l.push(a,h),h<c&&l.push(h,c),c<a&&l.push(c,a);else{const f=t.plus(e).toLength(1),d=e.plus(i).toLength(1),u=i.plus(t).toLength(1),m=n.length,E=m+1,p=m+2;n.push(f,d,u),r(f,d,u,s-1,n,o,m,E,p,l),r(t,f,u,s-1,n,o,a,m,p,l),r(e,d,f,s-1,n,o,h,E,m,l),r(i,u,d,s-1,n,o,c,p,E,l)}}const i=(1+Math.sqrt(5))/2,s=new e.V3(1,i,0).unit(),n=s.x,o=s.y,a=[new e.V3(-n,o,0),new e.V3(n,o,0),new e.V3(-n,-o,0),new e.V3(n,-o,0),new e.V3(0,-n,o),new e.V3(0,n,o),new e.V3(0,-n,-o),new e.V3(0,n,-o),new e.V3(o,0,-n),new e.V3(o,0,n),new e.V3(-o,0,-n),new e.V3(-o,0,n)],h=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],c=(new E).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");c.vertices.push(...a),t=void 0==t?4:t;for(let e=0;e<20;e++){const[i,s,n]=h.slice(3*e,3*e+3);r(a[i],a[s],a[n],t,c.vertices,c.TRIANGLES,i,s,n,c.LINES)}return c.normals=c.vertices,c.compile(),c}static aabb(t){const r=e.M4.multiplyMultiple(e.M4.translate(t.min),e.M4.scale(t.size().max(new e.V3(e.NLA_PRECISION,e.NLA_PRECISION,e.NLA_PRECISION)))),i=E.cube().transform(r);return i.computeNormalLines(20),i.compile(),i}static offsetVertices(t,r,i,s){e.assertVectors.apply(void 0,t),e.assertVectors(r);const n=(new E).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","LGL_TexCoord");s&&n.addVertexBuffer("normals","LGL_Normal"),n.vertices=t.concat(t.map(t=>t.plus(r)));const a=t.length;n.coords=e.arrayFromFunction(2*a,t=>[t%a/a,t/a|0]);const h=n.TRIANGLES;for(let e=0;e<t.length-1;e++)o(h,!1,e,e+1,t.length+e,t.length+e+1);return i&&o(h,!1,0,t.length-1,t.length,2*t.length-1),s&&(n.normals=s.concat(s)),n.compile(),n}static rotation(t,r,i,s,n=!0,a){const h=(new E).addIndexBuffer("TRIANGLES");a&&h.addVertexBuffer("normals","LGL_Normal");const c=t.length,l=c*s,f=new e.M4,d=h.TRIANGLES;for(let u=0;u<s;u++){const m=i/s*u;if(e.M4.rotateLine(r.anchor,r.dir1,m,f),h.vertices.push(...f.transformedPoints(t)),a&&h.normals.push(...f.transformedVectors(a)),n||u!==s-1)for(let t=0;t<c-1;t++)o(d,!1,u*c+t+1,u*c+t,((u+1)*c+t+1)%l,((u+1)*c+t)%l)}return h.compile(),h}static parametric(t,r,i,s,n,a,h,c){const l=(new E).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES");for(let f=0;f<=h;f++){const d=e.lerp(i,s,f/h);for(let i=0;i<=c;i++){const s=e.lerp(n,a,i/c);if(l.vertices.push(t(d,s)),l.normals.push(r(d,s)),i<c&&f<h){const t=i+f*(c+1);o(l.TRIANGLES,!1,t,t+c+1,t+1,t+c+2)}}}return l.compile(),l}static load(t){const r=new E;if(!Array.isArray(t.vertices[0]))throw new Error;return r.vertices=t.vertices.map(t=>e.V(t)),t.triangles&&(r.addIndexBuffer("TRIANGLES"),r.TRIANGLES=t.triangles),t.normals&&(r.addVertexBuffer("normals","LGL_Normal"),r.normals=t.normals),r.compile(),r}}E.UNIT_CUBE_CORNERS=[e.V3.O,new e.V3(0,0,1),new e.V3(0,1,0),new e.V3(0,1,1),new e.V3(1,0,0),new e.V3(1,0,1),new e.V3(1,1,0),e.V3.XYZ];const p=WebGLRenderingContext;!function(t){t[t.POINTS=p.POINTS]="POINTS",t[t.LINES=p.LINES]="LINES",t[t.LINE_STRIP=p.LINE_STRIP]="LINE_STRIP",t[t.LINE_LOOP=p.LINE_LOOP]="LINE_LOOP",t[t.TRIANGLES=p.TRIANGLES]="TRIANGLES",t[t.TRIANGLE_STRIP=p.TRIANGLE_STRIP]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=p.TRIANGLE_FAN]="TRIANGLE_FAN"}(t.DRAW_MODES||(t.DRAW_MODES={}));const L=[0,0,0,1],x=["FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT"],A={[t.DRAW_MODES.POINTS]:t=>!0,[t.DRAW_MODES.LINES]:t=>0==t%2,[t.DRAW_MODES.LINE_STRIP]:t=>t>2,[t.DRAW_MODES.LINE_LOOP]:t=>t>2,[t.DRAW_MODES.TRIANGLES]:t=>0==t%3,[t.DRAW_MODES.TRIANGLE_STRIP]:t=>t>3,[t.DRAW_MODES.TRIANGLE_FAN]:t=>t>3};class M{constructor(t,e,r=n()){function i(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,p.COMPILE_STATUS))throw new Error("compile error: "+r.getShaderInfoLog(i));return i}this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1;const s=`\n\t\tuniform mat3 LGL_NormalMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrix;\n\t\tuniform mat4 LGL_ProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrixInverse;\n\t\tuniform mat4 LGL_ProjectionMatrixInverse;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrixInverse;\n\t`,o=s+`\n\t\tattribute vec4 LGL_Vertex;\n\t\tattribute vec2 LGL_TexCoord;\n\t\tattribute vec3 LGL_Normal;\n\t\tattribute vec4 LGL_Color;\n\t`,a=`  precision highp float;`+s,h=s.match(/\bLGL_\w+/g);this.gl=r;const c=r.createProgram();if(c||r.handleError(),this.program=c,r.attachShader(this.program,i(p.VERTEX_SHADER,o+t)),r.attachShader(this.program,i(p.FRAGMENT_SHADER,a+e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,p.LINK_STATUS))throw new Error("link error: "+r.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={},this.activeMatrices={},h&&h.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,p.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}r.handleError()}static create(t,e){return new M(t,e)}uniforms(t){const r=this.gl;r.useProgram(this.program),r.handleError();for(const n in t){const o=this.uniformLocations[n]||r.getUniformLocation(this.program,n);if(!o&&console.warn(n+" uniform is not used in shader"),!o)continue;this.uniformLocations[n]=o;let a=t[n];const h=this.uniformInfos[n];if(e.NLA_DEBUG&&(r.SAMPLER_2D!=h.type&&r.SAMPLER_CUBE!=h.type&&r.INT!=h.type||(1==h.size?e.assert(Number.isInteger(a)):e.assert(s(a)&&a.length==h.size,"value must be int array if info.size != 1")),e.assert(r.FLOAT!=h.type||1==h.size&&"number"==typeof a||i(a)&&h.size==a.length),e.assert(r.FLOAT_VEC3!=h.type||1==h.size&&a instanceof e.V3||Array.isArray(a)&&h.size==a.length&&e.assertVectors(...a)),e.assert(r.FLOAT_VEC4!=h.type||i(a)&&4==a.length),e.assert(r.FLOAT_MAT4!=h.type||a instanceof e.M4,()=>a.toSource()),e.assert(r.FLOAT_MAT3!=h.type||9==a.length||a instanceof e.M4)),a instanceof e.V3&&(a=a.toArray()),a.length)switch(a.length){case 1:r.uniform1fv(o,a);break;case 2:r.uniform2fv(o,a);break;case 3:r.uniform3fv(o,a);break;case 4:r.uniform4fv(o,a);break;case 9:r.uniformMatrix3fv(o,!1,new Float32Array([a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]]));break;case 16:r.uniformMatrix4fv(o,!1,new Float32Array([a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15]]));break;default:throw new Error("don't know how to load uniform \""+n+'" of length '+a.length)}else if("number"==typeof a)r.SAMPLER_2D==h.type||r.SAMPLER_CUBE==h.type||r.INT==h.type?r.uniform1i(o,a):r.uniform1f(o,a);else if("boolean"==typeof a)r.uniform1i(o,+a);else{if(!(a instanceof e.M4))throw new Error('attempted to set uniform "'+n+'" to invalid value '+a);{const t=a.m;if(r.FLOAT_MAT4==h.type)r.uniformMatrix4fv(o,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(r.FLOAT_MAT3==h.type)r.uniformMatrix3fv(o,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(r.FLOAT_MAT2!=h.type)throw new Error(`Can't assign M4 to ${h.type}`);r.uniformMatrix2fv(o,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}r.handleError()}return this}draw(r,i=t.DRAW_MODES.TRIANGLES,s,n){e.assert(r.hasBeenCompiled,"mesh.hasBeenCompiled"),e.assert(void 0!=t.DRAW_MODES[i]);const o=t.DRAW_MODES[i];return this.drawBuffers(r.vertexBuffers,r.indexBuffers[o],i,s,n)}drawBuffers(r,i,s=t.DRAW_MODES.TRIANGLES,n=0,o){const a=this.gl;a.handleError(),e.assert(void 0!=t.DRAW_MODES[s]),e.assertf(()=>1<=Object.keys(r).length),Object.keys(r).forEach(t=>e.assertInst(T,r[t]));const h=this.activeMatrices,c=(h.LGL_ModelViewMatrixInverse||h.LGL_NormalMatrix)&&a.modelViewMatrix.inversed(),l=h.LGL_ProjectionMatrixInverse&&a.projectionMatrix.inversed(),f=(h.LGL_ModelViewProjectionMatrix||h.LGL_ModelViewProjectionMatrixInverse)&&a.projectionMatrix.times(a.modelViewMatrix),d={};h.LGL_ModelViewMatrix&&this.modelViewMatrixVersion!=a.modelViewMatrixVersion&&(d.LGL_ModelViewMatrix=a.modelViewMatrix),h.LGL_ModelViewMatrixInverse&&(d.LGL_ModelViewMatrixInverse=c),h.LGL_ProjectionMatrix&&this.projectionMatrixVersion!=a.projectionMatrixVersion&&(d.LGL_ProjectionMatrix=a.projectionMatrix),l&&(d.LGL_ProjectionMatrixInverse=l),f&&(d.LGL_ModelViewProjectionMatrix=f),f&&h.LGL_ModelViewProjectionMatrixInverse&&(d.LGL_ModelViewProjectionMatrixInverse=f.inversed()),h.LGL_NormalMatrix&&this.modelViewMatrixVersion!=a.modelViewMatrixVersion&&(d.LGL_NormalMatrix=c.transposed()),this.uniforms(d),this.projectionMatrixVersion=a.projectionMatrixVersion,this.modelViewMatrixVersion=a.modelViewMatrixVersion;let u=1/0;for(const t in r){const i=r[t];e.assert(i.hasBeenCompiled);const s=this.attributes[t]||a.getAttribLocation(this.program,t);a.handleError(),-1!=s&&i.buffer&&(this.attributes[t]=s,a.bindBuffer(p.ARRAY_BUFFER,i.buffer),a.handleError(),a.enableVertexAttribArray(s),a.handleError(),a.vertexAttribPointer(s,i.spacing,p.FLOAT,!1,0,0),a.handleError(),u=Math.min(u,i.count))}for(const t in this.attributes)t in r||(a.disableVertexAttribArray(this.attributes[t]),a.handleError());if(u){if(o=o||(i?i.count:u),e.assert(A[s](o),"count "+o+" doesn't fulfill requirement "+A[s].toString()+" for mode "+t.DRAW_MODES[s]),i){if(e.assert(i.hasBeenCompiled),e.assert(u>i.maxValue),e.assert(o%i.spacing==0),e.assert(n%i.spacing==0),n+o>i.count)throw new Error("Buffer not long enough for passed parameters start/length/buffer length "+n+" "+o+" "+i.count);a.bindBuffer(p.ELEMENT_ARRAY_BUFFER,i.buffer),a.handleError(),a.drawElements(s,o,p.UNSIGNED_SHORT,2*n),a.handleError()}else{if(n+o>u)throw new Error("invalid");a.drawArrays(s,n,o),a.handleError()}a.drawCallCount++}return this}}const _=WebGLRenderingContext;class g extends Object{constructor(t){super(),this.modelViewMatrix=new e.M4,this.projectionMatrix=new e.M4,this.MODELVIEW=g.MODELVIEW,this.PROJECTION=g.PROJECTION,this.tempMatrix=new e.M4,this.resultMatrix=new e.M4,this.modelViewStack=[],this.projectionStack=[],this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.immediate={mesh:(new E).addVertexBuffer("coords","LGL_TexCoord").addVertexBuffer("colors","LGL_Color"),mode:-1,coord:[0,0],color:[1,1,1,1],pointSize:1,shader:new M(`\n            uniform float pointSize;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                color = LGL_Color;\n                coord = LGL_TexCoord;\n                gl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n                gl_PointSize = pointSize;\n            }\n        `,`\n            uniform sampler2D texture;\n            uniform float pointSize;\n            uniform bool useTexture;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                gl_FragColor = color;\n                if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n            }\n        `)},this.matrixMode(g.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw new Error("invalid matrix mode "+t)}}loadIdentity(){e.M4.identity(this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}loadMatrix(t){e.M4.copy(t,this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}multMatrix(t){e.M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const r=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=r,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(e.M4.mirror(t))}perspective(t,r,i,s,n){this.multMatrix(e.M4.perspectiveRad(t*e.DEG,r,i,s,this.tempMatrix))}frustum(t,r,i,s,n,o){this.multMatrix(e.M4.frustum(t,r,i,s,n,o,this.tempMatrix))}ortho(t,r,i,s,n,o){this.multMatrix(e.M4.ortho(t,r,i,s,n,o,this.tempMatrix))}scale(...t){this.multMatrix(e.M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(e.M4.mirror(e.P3ZX))}translate(t,r,i){void 0!==r?this.multMatrix(e.M4.translate(t,r,i,this.tempMatrix)):this.multMatrix(e.M4.translate(t,this.tempMatrix))}rotate(t,r,i,s){this.multMatrix(e.M4.rotate(t*e.DEG,{x:r,y:i,z:s},this.tempMatrix))}lookAt(t,r,i){this.multMatrix(e.M4.lookAt(t,r,i,this.tempMatrix))}pushMatrix(){this.stack.push(e.M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();e.assert(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[r,i,s,n]=t,o=new e.M4([s/2,0,0,r+s/2,n/2,0,0,i+n/2,0,0,1,0,0,0,0,1]);return e.M4.multiplyMultiple(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?a(t[0]):1==t.length&&"string"==typeof t[0]?r(t[0]).gl():[t[0],t[1],t[2],t[3]||0]}texCoord(...t){this.immediate.coord=e.V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(e.V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!g.gl.getParameter(_.TEXTURE_BINDING_2D)}).drawBuffers(this.immediate.mesh.vertexBuffers,void 0,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){g.gl=this}animate(t){const e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let r=performance.now(),i=!0;const s=n=>{const o=performance.now();t.call(this,o,o-r),r=o,i&&e(s)};return e(s),()=>{i=!1}}fullscreen(t={}){function e(){o.canvas.width=window.innerWidth-i-s,o.canvas.height=window.innerHeight-r-n,o.viewport(0,0,o.canvas.width,o.canvas.height),t.camera&&(o.matrixMode(g.PROJECTION),o.loadIdentity(),o.perspective(t.fov||45,o.canvas.width/o.canvas.height,t.near||.1,t.far||1e3),o.matrixMode(g.MODELVIEW))}const r=t.paddingTop||0,i=t.paddingLeft||0,s=t.paddingRight||0,n=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");document.body.appendChild(this.canvas),document.body.style.overflow="hidden",this.canvas.style.position="absolute",this.canvas.style.left=i+"px",this.canvas.style.top=r+"px";const o=this;return window.addEventListener("resize",e),e(),this}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}handleError(){const t=this.getError();if(0!==t)throw new Error(""+t+w[t])}static create(t={}){const r=t.canvas||document.createElement("canvas");t.canvas||(r.width=800,r.height=600),"alpha"in t||(t.alpha=!1);let i=void 0;try{i=r.getContext("webgl",t),console.log("getting context")}catch(t){console.log(t,i)}try{i=i||r.getContext("experimental-webgl",t)}catch(t){console.log(t,i)}if(!i)throw new Error("WebGL not supported");return g.gl=i,e.addOwnProperties(i,g.prototype),e.addOwnProperties(i,new g(i)),i}}g.MODELVIEW=0,g.PROJECTION=1,g.HALF_FLOAT_OES=36193;var w;!function(t){t[t.NO_ERROR=_.NO_ERROR]="NO_ERROR",t[t.INVALID_ENUM=_.INVALID_ENUM]="INVALID_ENUM",t[t.INVALID_VALUE=_.INVALID_VALUE]="INVALID_VALUE",t[t.INVALID_OPERATION=_.INVALID_OPERATION]="INVALID_OPERATION",t[t.INVALID_FRAMEBUFFER_OPERATION=_.INVALID_FRAMEBUFFER_OPERATION]="INVALID_FRAMEBUFFER_OPERATION",t[t.OUT_OF_MEMORY=_.OUT_OF_MEMORY]="OUT_OF_MEMORY",t[t.CONTEXT_LOST_WEBGL=_.CONTEXT_LOST_WEBGL]="CONTEXT_LOST_WEBGL"}(w||(w={})),g.prototype.MODELVIEW=g.MODELVIEW,g.prototype.PROJECTION=g.PROJECTION,g.prototype.HALF_FLOAT_OES=g.HALF_FLOAT_OES;const R=WebGLRenderingContext;class T{constructor(t,r){this.target=t,this.type=r,e.assert(t==R.ARRAY_BUFFER||t==R.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),e.assert(r==Float32Array||r==Uint16Array,"type == Float32Array || type == Uint16Array"),this.buffer=void 0,this.type=r,this.data=[],this.count=0,this.spacing=0,this.hasBeenCompiled=!1}compile(t=R.STATIC_DRAW,r=n()){e.assert(R.STATIC_DRAW==t||R.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),r.handleError(),this.buffer=this.buffer||r.createBuffer(),r.handleError();let i;if(0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof e.V3)e.assert(!(this.data[0]instanceof e.V3)||this.type==Float32Array),e.V3.pack(this.data,i=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;i=new this.type(t);let r=this.data.length,s=t;for(;r--;){const t=this.data[r];let e=t.length;for(;e--;)i[--s]=t[e]}e.assert(0==s)}else i=new this.type(this.data);const t=this.data.length?i.length/this.data.length:0;e.assert(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),e.NLA_DEBUG&&(1e4<=i.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,i)),e.assert(0!==t),this.spacing=t,this.count=this.data.length}r.bindBuffer(this.target,this.buffer),r.handleError(),r.bufferData(this.target,i,t),r.handleError(),this.hasBeenCompiled=!0}}class I{constructor(t,e,r={},i=n()){this.gl=i,this.texture=i.createTexture(),i.handleError(),this.width=t,this.height=e,this.format=r.format||i.RGBA,this.type=r.type||i.UNSIGNED_BYTE;const s=r.filter||r.magFilter||i.LINEAR,o=r.filter||r.minFilter||i.LINEAR;if(this.type===i.FLOAT){if(!i.getExtension("OES_texture_float"))throw new Error("OES_texture_float is required but not supported");if((o!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===g.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw new Error("OES_texture_half_float is required but not supported");if((o!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw new Error("OES_texture_half_float_linear is required but not supported")}i.bindTexture(i.TEXTURE_2D,this.texture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,r.wrap||r.wrapS||i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,r.wrap||r.wrapT||i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,this.format,t,e,0,this.format,this.type,null)}bind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}unbind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}canDrawTo(){const t=this.gl;this.framebuffer=this.framebuffer||t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0);const e=t.checkFramebufferStatus(t.FRAMEBUFFER)==t.FRAMEBUFFER_COMPLETE;return t.bindFramebuffer(t.FRAMEBUFFER,null),e}drawTo(t){const e=this.gl;if(this.framebuffer=this.framebuffer||e.createFramebuffer(),this.renderbuffer=this.renderbuffer||e.createRenderbuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.bindRenderbuffer(e.RENDERBUFFER,this.renderbuffer),this.width==this.renderbuffer.width&&this.height==this.renderbuffer.height||(this.renderbuffer.width=this.width,this.renderbuffer.height=this.height,e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.renderbuffer),e.checkFramebufferStatus(e.FRAMEBUFFER)!=e.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete this.framebuffer)");const r=e.getParameter(e.VIEWPORT);e.viewport(0,0,this.width,this.height),t(e),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.viewport(r[0],r[1],r[2],r[3])}swapWith(t){e.assert(this.gl==t.gl);let r;r=t.texture,t.texture=this.texture,this.texture=r,r=t.width,t.width=this.width,this.width=r,r=t.height,t.height=this.height,this.height=r}static fromImage(t,e,r=n()){e=e||{};const i=new I(t.width,t.height,e);try{r.texImage2D(r.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?new Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):new Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=r.NEAREST&&e.minFilter!=r.LINEAR&&r.generateMipmap(r.TEXTURE_2D),i}static fromURL(t,e={},r=n()){I.checkerBoardCanvas=I.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=I.fromImage(I.checkerBoardCanvas,e),s=new Image;return s.onload=(()=>I.fromImage(s,e,r).swapWith(i)),s.src=t,i}}t.Buffer=T,t.Mesh=E,t.GL_COLOR_BLACK=L,t.SHADER_VAR_TYPES=x,t.isArray=function(t){return Array==t.constructor||Float32Array==t.constructor||Float64Array==t.constructor},t.Shader=M,t.Texture=I,t.currentGL=n,t.isNumber=function(t){const e=Object.prototype.toString.call(t);return"[object Number]"==e||"[object Boolean]"==e},t.LightGLContext=g,t.pushQuad=o,Object.defineProperty(t,"__esModule",{value:!0})});
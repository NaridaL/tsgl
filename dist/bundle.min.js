!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("chroma-js")):"function"==typeof define&&define.amd?define(["exports","chroma-js"],e):e(t.nla={},t.chroma)}(this,function(t,e){"use strict";function r(t){return Array==t.constructor||Float32Array==t.constructor||Float64Array==t.constructor}function i(){return l.gl}function s(t,e,r,i,s,o){e?t.push(r,s,i,i,s,o):t.push(r,i,s,i,o,s)}function o(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}e=e&&e.hasOwnProperty("default")?e.default:e;class n extends Transformable{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","LGL_Vertex")}calcVolume(){let t=0,e=V3.O,r=0;const i=this.TRIANGLES,s=this.vertices;for(let o=0;o<i.length;o+=3){const n=i[o+0],a=i[o+1],h=i[o+2],c=s[n],l=s[a],d=s[h],f=l.minus(c),m=d.minus(c),u=f.cross(m),E=c.plus(l.plus(d)).div(3);t+=E.z*u.z/2,r+=u.length(),e=e.plus(new V3(E.x,E.y,E.z/2).times(E.z*u.z/2))}return{volume:t,centroid:e.div(i.length/3),area:r/2}}addVertexBuffer(t,e){return assert(!this.vertexBuffers[e]),this.hasBeenCompiled=!1,assert("string"==typeof t),assert("string"==typeof e),(this.vertexBuffers[e]=new E(c.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t){return this.hasBeenCompiled=!1,(this.indexBuffers[t]=new E(c.ELEMENT_ARRAY_BUFFER,Uint16Array)).name=t,this[t]=[],this}concat(...t){const e=new n;return[this].concat(t).forEach(t=>{const r=e.vertices?e.vertices.length:0;Object.getOwnPropertyNames(t.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r].name;e.vertexBuffers[r]||e.addVertexBuffer(i,r),e[i].push(t[i])}),Object.getOwnPropertyNames(t.indexBuffers).forEach(i=>{e.indexBuffers[i]||e.addIndexBuffer(i),e[i].push(...t[i].map(t=>t+r))})}),e}compile(){Object.getOwnPropertyNames(this.vertexBuffers).forEach(t=>{const e=this.vertexBuffers[t];e.data=this[e.name],e.compile()});for(const t in this.indexBuffers){const e=this.indexBuffers[t];e.data=this[e.name],e.compile()}this.hasBeenCompiled=!0}toBinarySTL(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const t=this.TRIANGLES,e=t.length/3,r=new ArrayBuffer(84+50*e),i=new DataView(r);i.setUint32(80,e,!0);let s=84,o=t.length;for(;o;){o-=3;const e=this.vertices[t[o]],r=this.vertices[t[o+1]],n=this.vertices[t[o+2]];[V3.normalOnPoints(e,r,n),e,r,n].forEach(t=>{i.setFloat32(s,t.x,!0),s+=4,i.setFloat32(s,t.y,!0),s+=4,i.setFloat32(s,t.z,!0),s+=4}),s+=2}return assert(s==r.byteLength,s+" "+r.byteLength),new Blob([r],{type:"application/octet-stream"})}transform(t){const e=new n;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","LGL_Normal");const r=t.as3x3().inversed().transposed().normalized();e.normals=this.normals.map(t=>r.transformVector(t)),e.normals.forEach(t=>assert(t.hasLength(1)))}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];return e.compile(),e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","LGL_Normal"),this.vertexBuffers.LGL_Normal.data=arrayFromFunction(this.vertices.length,t=>V3.O);const t=this.TRIANGLES,e=this.vertices,r=this.normals;for(let i=0;i<t.length;i+=3){const s=t[i],o=t[i+1],n=t[i+2],a=e[s],h=e[o],c=e[n],l=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s].plus(l),r[o]=r[o].plus(l),r[n]=r[n].plus(l)}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this}computeWireframeFromFlatTriangles(t="LINES"){function e(t,e){return min(t,e)<<16|max(t,e)}if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const r=new Set,i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)r.add(e(i[t+0],i[t+1])),r.add(e(i[t+1],i[t+2])),r.add(e(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),r.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const t=this.TRIANGLES,e=this.LINES;for(let r=0;r<t.length;r+=3)t[r+0]<t[r+1]&&e.push(t[r+0],t[r+1]),t[r+1]<t[r+2]&&e.push(t[r+1],t[r+2]),t[r+2]<t[r+0]&&e.push(t[r+2],t[r+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.vertices||!this.normals)throw new Error("Both vertices and normals must be defined.");const r=this.vertices,i=this.vertices.length,s=e;this[s]||this.addIndexBuffer(e);for(let e=0;e<this.normals.length;e++)r[i+e]=r[e].plus(this.normals[e].toLength(t)),this[s].push(i+e,e);return this.hasBeenCompiled=!1,this}getAABB(){return(new AABB).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const e=t.detailX||t.detail||1,r=t.detailY||t.detail||1,i=t.startX||0,s=t.startY||0,o=t.width||1,a=t.height||1,h=(new n).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal").addVertexBuffer("coords","LGL_TexCoord");for(let t=0;t<=r;t++){const n=t/r;for(let c=0;c<=e;c++){const l=c/e;if(h.vertices.push(new V3(i+l*o,s+n*a,0)),h.coords.push(l,n),h.normals.push(V3.Z),c<e&&t<r){const r=c+t*(e+1);h.TRIANGLES.push(r,r+e+1,r+1,r+e+1,r+e+2,r+1)}}}for(let t=0;t<e;t++)h.LINES.push(t,t+1),h.LINES.push((e+1)*r+t,(e+1)*r+t+1);for(let t=0;t<r;t++)h.LINES.push(e*t,e*(t+1)+1),h.LINES.push(e*(t+1),e*(t+2)+1);return h.compile(),h}static cube(){const t=(new n).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e=[0,1,2,3,4,5,6,7,0,4,1,5,2,6,3,7,2,6,0,4,3,7,1,5];t.vertices=e.map(t=>n.UNIT_CUBE_CORNERS[t]),t.normals=[V3.X.negated(),V3.X,V3.Y.negated(),V3.Y,V3.Z.negated(),V3.Z].map(t=>[t,t,t,t]).concatenated();for(let r=0;r<24;r+=4)s(t.TRIANGLES,0!=r%8,e[r],e[r+1],e[r+2],e[r+3]);return t.LINES=[0,1,0,2,1,3,2,3,0,4,1,5,2,6,3,7,4,5,4,6,5,7,6,7].map(t=>e.indexOf(t)),t.compile(),t}static isocahedron(){return n.sphere(0)}static sphere2(t,e){const r=arrayFromFunction(t,e=>{const r=e/(t-1)*PI-PI/2;return new V3(0,cos(r),sin(r))});return n.rotation(r,{anchor:V3.O,dir1:V3.Z},2*PI,e,!0,r)}static sphere(t=3){function e(t,r,i,s,o,n,a,h,c,l){if(0==s)n.push(a,h,c),a<h&&l.push(a,h),h<c&&l.push(h,c),c<a&&l.push(c,a);else{const d=t.plus(r).toLength(1),f=r.plus(i).toLength(1),m=i.plus(t).toLength(1),u=o.length,E=u+1,p=u+2;o.push(d,f,m),e(d,f,m,s-1,o,n,u,E,p,l),e(t,d,m,s-1,o,n,a,u,p,l),e(r,f,d,s-1,o,n,h,E,u,l),e(i,m,f,s-1,o,n,c,p,E,l)}}const r=(1+Math.sqrt(5))/2,i=new V3(1,r,0).unit(),s=i.x,o=i.y,a=[new V3(-s,o,0),new V3(s,o,0),new V3(-s,-o,0),new V3(s,-o,0),new V3(0,-s,o),new V3(0,s,o),new V3(0,-s,-o),new V3(0,s,-o),new V3(o,0,-s),new V3(o,0,s),new V3(-o,0,-s),new V3(-o,0,s)],h=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],c=(new n).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");c.vertices.push(...a),t=void 0==t?4:t;for(let r=0;r<20;r++){const[i,s,o]=h.slice(3*r,3*r+3);e(a[i],a[s],a[o],t,c.vertices,c.TRIANGLES,i,s,o,c.LINES)}return c.normals=c.vertices,c.compile(),c}static aabb(t){const e=M4.multiplyMultiple(M4.translate(t.min),M4.scale(t.size().max(new V3(NLA_PRECISION,NLA_PRECISION,NLA_PRECISION)))),r=n.cube().transform(e);return r.computeNormalLines(20),r.compile(),r}static offsetVertices(t,e,r,i,o){assertVectors.apply(void 0,t),assertVectors(e);const a=(new n).addIndexBuffer("TRIANGLES");i&&a.addVertexBuffer("normals","LGL_Normal"),a.vertices=t.concat(t.map(t=>t.plus(e)));const h=a.TRIANGLES;for(let e=0;e<t.length-1;e++)s(h,!1,e,e+1,t.length+e,t.length+e+1);return r&&s(h,!1,0,t.length-1,t.length,2*t.length-1),i&&(a.normals=i.concat(i)),a.compile(),a}static rotation(t,e,r,i,o=!0,a){const h=(new n).addIndexBuffer("TRIANGLES");a&&h.addVertexBuffer("normals","LGL_Normal");const c=t.length,l=c*i,d=new M4,f=h.TRIANGLES;for(let n=0;n<i;n++){const m=r/i*n;if(M4.rotateLine(e.anchor,e.dir1,m,d),h.vertices.push(...d.transformedPoints(t)),a&&h.normals.push(...d.transformedVectors(a)),o||n!==i-1)for(let t=0;t<c-1;t++)s(f,!1,n*c+t+1,n*c+t,((n+1)*c+t+1)%l,((n+1)*c+t)%l)}return h.compile(),h}static parametric(t,e,r,i,o,a,h,c){const l=(new n).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES");for(let n=0;n<=h;n++){const d=lerp(r,i,n/h);for(let r=0;r<=c;r++){const i=lerp(o,a,r/c);if(l.vertices.push(t(d,i)),l.normals.push(e(d,i)),r<c&&n<h){const t=r+n*(c+1);s(l.TRIANGLES,!1,t,t+c+1,t+1,t+c+2)}}}return l.compile(),l}}n.UNIT_CUBE_CORNERS=[V3.O,new V3(0,0,1),new V3(0,1,0),new V3(0,1,1),new V3(1,0,0),new V3(1,0,1),new V3(1,1,0),V3.XYZ];const a={[t.DRAW_MODES.POINTS]:t=>!0,[t.DRAW_MODES.LINES]:t=>0==t%2,[t.DRAW_MODES.LINE_STRIP]:t=>t>2,[t.DRAW_MODES.LINE_LOOP]:t=>t>2,[t.DRAW_MODES.TRIANGLES]:t=>0==t%3,[t.DRAW_MODES.TRIANGLE_STRIP]:t=>t>3,[t.DRAW_MODES.TRIANGLE_FAN]:t=>t>3};class h{constructor(t,e,r=i()){function s(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,c.COMPILE_STATUS))throw new Error("compile error: "+r.getShaderInfoLog(i));return i}this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1;const o=`\n\t\tuniform mat3 LGL_NormalMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrix;\n\t\tuniform mat4 LGL_ProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrixInverse;\n\t\tuniform mat4 LGL_ProjectionMatrixInverse;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrixInverse;\n\t`,n=o+`\n\t\tattribute vec4 LGL_Vertex;\n\t\tattribute vec4 LGL_TexCoord;\n\t\tattribute vec3 LGL_Normal;\n\t\tattribute vec4 LGL_Color;\n\t`,a=`  precision highp float;`+o,h=o.match(/\bLGL_\w+/g);this.gl=r;const l=r.createProgram();if(l||r.handleError(),this.program=l,r.attachShader(this.program,s(c.VERTEX_SHADER,n+t)),r.attachShader(this.program,s(c.FRAGMENT_SHADER,a+e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,c.LINK_STATUS))throw new Error("link error: "+r.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={},this.activeMatrices={},h&&h.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,c.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}r.handleError()}static create(t,e){return new h(t,e)}uniforms(t){const e=this.gl;e.useProgram(this.program),e.handleError();for(const i in t){const s=this.uniformLocations[i]||e.getUniformLocation(this.program,i);if(assert(!!s,i+" uniform is not used in shader"),!s)continue;this.uniformLocations[i]=s;let o=t[i];const n=this.uniformInfos[i];if(NLA_DEBUG&&(assert(n.type!=c.FLOAT||1==n.size&&"number"==typeof o||r(o)&&n.size==o.length&&assertNumbers.apply(void 0,o)),assert(n.type!=c.INT||1==n.size&&"number"==typeof o&&o%1==0||r(o)&&n.size==o.length&&assertNumbers.apply(void 0,o)&&o.every(t=>t%1==0)),assert(n.type!=c.FLOAT_VEC3||1==n.size&&o instanceof V3||r(o)&&n.size==o.length&&assertVectors.apply(void 0,o)),assert(n.type!=c.FLOAT_VEC4||r(o)&&4==o.length),assert(n.type!=c.FLOAT_MAT4||o instanceof M4,()=>o.toSource()),assert(n.type!=c.FLOAT_MAT3||9==o.length||o instanceof M4)),o instanceof V3&&(o=o.toArray()),r(o))switch(o.length){case 1:e.uniform1fv(s,o);break;case 2:e.uniform2fv(s,o);break;case 3:e.uniform3fv(s,o);break;case 4:e.uniform4fv(s,o);break;case 9:e.uniformMatrix3fv(s,!1,new Float32Array([o[0],o[3],o[6],o[1],o[4],o[7],o[2],o[5],o[8]]));break;case 16:e.uniformMatrix4fv(s,!1,new Float32Array([o[0],o[4],o[8],o[12],o[1],o[5],o[9],o[13],o[2],o[6],o[10],o[14],o[3],o[7],o[11],o[15]]));break;default:throw new Error("don't know how to load uniform \""+i+'" of length '+o.length)}else if(Number.isInteger(o))c.SAMPLER_2D==n.type||c.SAMPLER_CUBE==n.type||c.INT==n.type?e.uniform1i(s,o):e.uniform1f(s,o);else{if(!(o instanceof M4))throw new Error('attempted to set uniform "'+i+'" to invalid value '+o);{const t=o.m;if(c.FLOAT_MAT4==n.type)e.uniformMatrix4fv(s,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(c.FLOAT_MAT3==n.type)e.uniformMatrix3fv(s,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(c.FLOAT_MAT2!=n.type)throw new Error(`Can't assign M4 to ${n.type}`);e.uniformMatrix2fv(s,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}e.handleError()}return this}draw(e,r=t.DRAW_MODES.TRIANGLES,i,s){assert(e.hasBeenCompiled,"mesh.hasBeenCompiled"),assert(void 0!=t.DRAW_MODES[r]);const o=t.DRAW_MODES[r];return assert(e.indexBuffers[o],`mesh.indexBuffers[${o}] undefined`),this.drawBuffers(e.vertexBuffers,e.indexBuffers[o],r,i,s)}drawBuffers(e,r,i=t.DRAW_MODES.TRIANGLES,s=0,o){const n=this.gl;n.handleError(),assert(void 0!=t.DRAW_MODES[i]),assertf(()=>1<=Object.keys(e).length),Object.keys(e).forEach(t=>assertInst(E,e[t]));const h=this.activeMatrices,l=(h.LGL_ModelViewMatrixInverse||h.LGL_NormalMatrix)&&this.modelViewMatrixVersion!=n.modelViewMatrixVersion&&n.modelViewMatrix.inversed(),d=h.LGL_ProjectionMatrixInverse&&this.projectionMatrixVersion!=n.projectionMatrixVersion&&n.projectionMatrix.inversed(),f=(h.LGL_ModelViewProjectionMatrix||h.LGL_ModelViewProjectionMatrixInverse)&&(this.projectionMatrixVersion!=n.projectionMatrixVersion||this.modelViewMatrixVersion!=n.modelViewMatrixVersion)&&n.projectionMatrix.times(n.modelViewMatrix),m={};h.LGL_ModelViewMatrix&&this.modelViewMatrixVersion!=n.modelViewMatrixVersion&&(m.LGL_ModelViewMatrix=n.modelViewMatrix),h.LGL_ModelViewMatrixInverse&&(m.LGL_ModelViewMatrixInverse=l),h.LGL_ProjectionMatrix&&this.projectionMatrixVersion!=n.projectionMatrixVersion&&(m.LGL_ProjectionMatrix=n.projectionMatrix),d&&(m.LGL_ProjectionMatrixInverse=d),f&&(m.LGL_ModelViewProjectionMatrix=f),f&&h.LGL_ModelViewProjectionMatrixInverse&&(m.LGL_ModelViewProjectionMatrixInverse=f.inversed()),h.LGL_NormalMatrix&&this.modelViewMatrixVersion!=n.modelViewMatrixVersion&&(m.LGL_NormalMatrix=l.transposed()),this.uniforms(m),this.projectionMatrixVersion=n.projectionMatrixVersion,this.modelViewMatrixVersion=n.modelViewMatrixVersion;let u=1/0;for(const t in e){const r=e[t];assert(r.hasBeenCompiled);const i=this.attributes[t]||n.getAttribLocation(this.program,t);n.handleError(),-1!=i&&r.buffer&&(this.attributes[t]=i,n.bindBuffer(c.ARRAY_BUFFER,r.buffer),n.handleError(),n.enableVertexAttribArray(i),n.handleError(),n.vertexAttribPointer(i,r.spacing,c.FLOAT,!1,0,0),n.handleError(),u=Math.min(u,r.count))}for(const t in this.attributes)t in e||(n.disableVertexAttribArray(this.attributes[t]),n.handleError());if(u){if(o=o||(r?r.count:u),assert(a[i](o),"count "+o+" doesn't fulfill requirement "+a[i].toString()+" for mode "+t.DRAW_MODES[i]),r){if(assert(r.hasBeenCompiled),assert(u>r.maxValue),assert(o%r.spacing==0),assert(s%r.spacing==0),s+o>r.count)throw new Error("Buffer not long enough for passed parameters start/length/buffer length "+s+" "+o+" "+r.count);n.bindBuffer(c.ELEMENT_ARRAY_BUFFER,r.buffer),n.handleError(),n.drawElements(i,o,c.UNSIGNED_SHORT,2*s),n.handleError()}else{if(s+o>u)throw new Error("invalid");n.drawArrays(i,s,o),n.handleError()}n.drawCallCount++}return this}}const c=WebGLRenderingContext;class l extends WebGLRenderingContext{constructor(){super(),this.modelViewMatrix=new M4,this.projectionMatrix=new M4,this.MODELVIEW={},this.PROJECTION={},this.tempMatrix=new M4,this.resultMatrix=new M4,this.modelViewStack=[],this.projectionStack=[]}init(){this.modelViewMatrix=new M4,this.projectionMatrix=new M4,this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.tempMatrix=new M4,this.resultMatrix=new M4,this.modelViewStack=[],this.projectionStack=[],this.immediate={mesh:(new n).addVertexBuffer("coords","LGL_TexCoord").addVertexBuffer("vertices","LGL_Vertex").addVertexBuffer("colors","LGL_Color"),mode:-1,coord:[0,0,0,0],color:[1,1,1,1],pointSize:1,shader:new h(`\nuniform float pointSize;\nvarying vec4 color;\nvarying vec4 coord;\nvoid main() {\n\tcolor = LGL_Color;\n\tcoord = LGL_TexCoord;\n\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\tgl_PointSize = pointSize;\n}`,`\nuniform sampler2D texture;\nuniform float pointSize;\nuniform bool useTexture;\nvarying vec4 color;\nvarying vec4 coord;\nvoid main() {\n\tgl_FragColor = color;\n\tif (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n}`)},this.matrixMode(l.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw new Error("invalid matrix mode "+t)}}modelViewMode(){Object.defineProperty(l.gl,"currentMatrix",{get:function(){return this.modelViewMatrix},set:function(t){this.modelViewMatrix=t},writable:!0}),this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack}projectionMode(){this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack}loadIdentity(){M4.identity(this[this.currentMatrixName])}loadMatrix(t){M4.copy(t,this[this.currentMatrixName])}multMatrix(t){M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const e=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=e,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(M4.mirror(t))}perspective(t,e,r,i,s){this.multMatrix(M4.perspectiveRad(t*DEG,e,r,i,this.tempMatrix))}frustum(t,e,r,i,s,o){this.multMatrix(M4.frustum(t,e,r,i,s,o,this.tempMatrix))}ortho(t,e,r,i,s,o){this.multMatrix(M4.ortho(t,e,r,i,s,o,this.tempMatrix))}scale(...t){this.multMatrix(M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(M4.mirror(P3ZX))}translate(t,e,r){void 0!==e?this.multMatrix(M4.translate(t,e,r,this.tempMatrix)):this.multMatrix(M4.translate(t,this.tempMatrix))}rotate(t,e,r,i){this.multMatrix(M4.rotate(t,{x:e,y:r,z:i},this.tempMatrix))}lookAt(t,e,r){this.multMatrix(M4.lookAt(t,e,r,this.tempMatrix))}pushMatrix(){this.stack.push(M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();assert(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[e,r,i,s]=t,o=new M4([i/2,0,0,e+i/2,s/2,0,0,r+s/2,0,0,1,0,0,0,0,1]);return M4.multiplyMultiple(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw new Error("mismatched begin() and end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?o(t[0]):1==t.length&&"string"==typeof t[0]?e(t[0]).gl():[t[0],t[1],t[2],t[3]||0]}texCoord(...t){this.immediate.coord=V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!l.gl.getParameter(c.TEXTURE_BINDING_2D)}).draw(this.immediate.mesh,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){l.gl=this}animate(){const t=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let e=(new Date).getTime();const r=()=>{const i=(new Date).getTime();this.onupdate&&this.onupdate(i-e),this.ondraw&&this.ondraw(),t(r),e=i};r()}fullscreen(t={}){function e(){n.canvas.width=window.innerWidth-i-s,n.canvas.height=window.innerHeight-r-o,n.viewport(0,0,n.canvas.width,n.canvas.height),t.camera&&(n.matrixMode(l.PROJECTION),n.loadIdentity(),n.perspective(t.fov||45,n.canvas.width/n.canvas.height,t.near||.1,t.far||1e3),n.matrixMode(l.MODELVIEW)),n.ondraw&&n.ondraw()}const r=t.paddingTop||0,i=t.paddingLeft||0,s=t.paddingRight||0,o=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");document.body.appendChild(this.canvas),document.body.style.overflow="hidden",this.canvas.style.position="absolute",this.canvas.style.left=i+"px",this.canvas.style.top=r+"px";const n=this;window.addEventListener("resize",e),e()}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}handleError(){const t=this.getError();if(0!==t)throw new Error(""+t+d[t])}static create(t={}){const e=t.canvas||document.createElement("canvas");t.canvas||(e.width=800,e.height=600),"alpha"in t||(t.alpha=!1);let r=void 0;try{r=e.getContext("webgl",t),console.log("getting context")}catch(t){console.log(t,r)}try{r=r||e.getContext("experimental-webgl",t)}catch(t){console.log(t,r)}if(!r)throw new Error("WebGL not supported");return addOwnProperties(r,l.prototype),l.gl=r,r.init(),r}}l.MODELVIEW={},l.PROJECTION={},l.HALF_FLOAT_OES=36193;var d;!function(t){t[t.NO_ERROR=c.NO_ERROR]="NO_ERROR",t[t.INVALID_ENUM=c.INVALID_ENUM]="INVALID_ENUM",t[t.INVALID_VALUE=c.INVALID_VALUE]="INVALID_VALUE",t[t.INVALID_OPERATION=c.INVALID_OPERATION]="INVALID_OPERATION",t[t.INVALID_FRAMEBUFFER_OPERATION=c.INVALID_FRAMEBUFFER_OPERATION]="INVALID_FRAMEBUFFER_OPERATION",t[t.OUT_OF_MEMORY=c.OUT_OF_MEMORY]="OUT_OF_MEMORY",t[t.CONTEXT_LOST_WEBGL=c.CONTEXT_LOST_WEBGL]="CONTEXT_LOST_WEBGL"}(d||(d={})),l.prototype.MODELVIEW=l.MODELVIEW,l.prototype.PROJECTION=l.PROJECTION,l.prototype.HALF_FLOAT_OES=l.HALF_FLOAT_OES,function(t){t[t.POINTS=c.POINTS]="POINTS",t[t.LINES=c.LINES]="LINES",t[t.LINE_STRIP=c.LINE_STRIP]="LINE_STRIP",t[t.LINE_LOOP=c.LINE_LOOP]="LINE_LOOP",t[t.TRIANGLES=c.TRIANGLES]="TRIANGLES",t[t.TRIANGLE_STRIP=c.TRIANGLE_STRIP]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=c.TRIANGLE_FAN]="TRIANGLE_FAN"}(t.DRAW_MODES||(t.DRAW_MODES={}));const f=[0,0,0,1],m=["FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT"],u=WebGLRenderingContext;class E{constructor(t,e){this.target=t,this.type=e,assert(t==u.ARRAY_BUFFER||t==u.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),assert(e==Float32Array||e==Uint16Array,"type == Float32Array || type == Uint16Array"),this.buffer=void 0,this.type=e,this.data=[],this.count=0,this.spacing=0,this.hasBeenCompiled=!1}compile(t=u.STATIC_DRAW,e=i()){assert(u.STATIC_DRAW==t||u.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),e.handleError(),this.buffer=this.buffer||e.createBuffer(),e.handleError();let r;if(0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof V3)assert(!(this.data[0]instanceof V3)||this.type==Float32Array),V3.pack(this.data,r=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;r=new this.type(t);let e=this.data.length,i=t;for(;e--;){const t=this.data[e];let s=t.length;for(;s--;)r[--i]=t[s]}assert(0==i)}else r=new this.type(this.data);const t=this.data.length?r.length/this.data.length:0;assert(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),NLA_DEBUG&&(1e4<=r.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,r)),assert(0!==t),this.spacing=t,this.count=this.data.length}e.bindBuffer(this.target,this.buffer),e.handleError(),e.bufferData(this.target,r,t),e.handleError(),this.hasBeenCompiled=!0}}class p{constructor(t,e,r,s=i()){this.gl=s,r=r||{},this.texture=s.createTexture(),s.handleError(),this.width=t,this.gl=s,this.height=e,this.format=r.format||c.RGBA,this.type=r.type||c.UNSIGNED_BYTE;const o=r.filter||r.magFilter||c.LINEAR,n=r.filter||r.minFilter||c.LINEAR;if(this.type===c.FLOAT){if(!s.getExtension("OES_texture_float"))throw new Error("OES_texture_float is required but not supported");if((n!==c.NEAREST||o!==c.NEAREST)&&!s.getExtension("OES_texture_float_linear"))throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===l.HALF_FLOAT_OES){if(!s.getExtension("OES_texture_half_float"))throw new Error("OES_texture_half_float is required but not supported");if((n!==c.NEAREST||o!==c.NEAREST)&&!s.getExtension("OES_texture_half_float_linear"))throw new Error("OES_texture_half_float_linear is required but not supported")}s.bindTexture(c.TEXTURE_2D,this.texture),s.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,1),s.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,o),s.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,n),s.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,r.wrap||r.wrapS||c.CLAMP_TO_EDGE),s.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,r.wrap||r.wrapT||c.CLAMP_TO_EDGE),s.texImage2D(c.TEXTURE_2D,0,this.format,t,e,0,this.format,this.type,null)}bind(t=0){this.gl.activeTexture(c.TEXTURE0+t),this.gl.bindTexture(c.TEXTURE_2D,this.texture)}unbind(t=0){this.gl.activeTexture(c.TEXTURE0+t),this.gl.bindTexture(c.TEXTURE_2D,null)}canDrawTo(){const t=this.gl;this.framebuffer=this.framebuffer||t.createFramebuffer(),t.bindFramebuffer(c.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,this.texture,0);const e=t.checkFramebufferStatus(c.FRAMEBUFFER)==c.FRAMEBUFFER_COMPLETE;return t.bindFramebuffer(c.FRAMEBUFFER,null),e}drawTo(t){const e=this.gl;if(this.framebuffer=this.framebuffer||e.createFramebuffer(),this.renderbuffer=this.renderbuffer||e.createRenderbuffer(),e.bindFramebuffer(c.FRAMEBUFFER,this.framebuffer),e.bindRenderbuffer(c.RENDERBUFFER,this.renderbuffer),this.width==this.renderbuffer.width&&this.height==this.renderbuffer.height||(this.renderbuffer.width=this.width,this.renderbuffer.height=this.height,e.renderbufferStorage(c.RENDERBUFFER,c.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(c.FRAMEBUFFER,c.DEPTH_ATTACHMENT,c.RENDERBUFFER,this.renderbuffer),e.checkFramebufferStatus(c.FRAMEBUFFER)!=c.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete this.framebuffer)");e.viewport(0,0,this.width,this.height),t(e),e.bindFramebuffer(c.FRAMEBUFFER,null),e.bindRenderbuffer(c.RENDERBUFFER,null);const r=e.getParameter(c.VIEWPORT);e.viewport(r[0],r[1],r[2],r[3])}swapWith(t){assert(this.gl==t.gl);let e;e=t.texture,t.texture=this.texture,this.texture=e,e=t.width,t.width=this.width,this.width=e,e=t.height,t.height=this.height,this.height=e}static fromImage(t,e,r=i()){e=e||{};const s=new p(t.width,t.height,e);try{r.texImage2D(c.TEXTURE_2D,0,s.format,s.format,s.type,t)}catch(t){throw"file:"==location.protocol?new Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):new Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=c.NEAREST&&e.minFilter!=c.LINEAR&&r.generateMipmap(c.TEXTURE_2D),s}static fromURL(t,e,r=i()){p.checkerBoardCanvas=p.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const s=p.fromImage(p.checkerBoardCanvas,e),o=new Image;return o.onload=(()=>p.fromImage(o,e,r).swapWith(s)),o.src=t,s}}t.Buffer=E,t.currentGL=i,t.WGL=c,t.LightGLContext=l,t.pushQuad=s,t.hexIntToGLColor=o,t.GL_COLOR_BLACK=f,t.SHADER_VAR_TYPES=m,t.Mesh=n,t.Shader=h,t.Texture=p,Object.defineProperty(t,"__esModule",{value:!0})});
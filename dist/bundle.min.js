!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("ts3dutils"),require("chroma-js")):"function"==typeof define&&define.amd?define(["exports","ts3dutils","chroma-js"],e):e(t.tsgl={},t.ts3dutils,t.chroma)}(this,function(t,e,r){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r;var i=function(t,e,r,i){return new(r||(r=Promise))(function(s,n){function o(t){try{h(i.next(t))}catch(t){n(t)}}function a(t){try{h(i.throw(t))}catch(t){n(t)}}function h(t){t.done?s(t.value):new r(function(e){e(t.value)}).then(o,a)}h((i=i.apply(t,e||[])).next())})};const{cos:s,sin:n,PI:o,min:a,max:h}=Math,c=WebGLRenderingContext;class l extends e.Transformable{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","LGL_Vertex")}calcVolume(){let t=0,r=e.V3.O,i=0;const s=this.TRIANGLES,n=this.vertices;for(let o=0;o<s.length;o+=3){const a=s[o+0],h=s[o+1],c=s[o+2],l=n[a],d=n[h],f=n[c],u=d.minus(l),m=f.minus(l),E=u.cross(m),p=l.plus(d.plus(f)).div(3);t+=p.z*E.z/2,i+=E.length(),r=r.plus(new e.V3(p.x,p.y,p.z/2).times(p.z*E.z/2))}return{volume:t,centroid:r.div(s.length/3),area:i/2}}addVertexBuffer(t,r){return e.assert(!this.vertexBuffers[r],"Buffer "+r+" already exists."),this.hasBeenCompiled=!1,e.assert("string"==typeof t),e.assert("string"==typeof r),(this.vertexBuffers[r]=new w(c.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t){return this.hasBeenCompiled=!1,(this.indexBuffers[t]=new w(c.ELEMENT_ARRAY_BUFFER,Uint16Array)).name=t,this[t]=[],this}concat(...t){const e=new l;return[this].concat(t).forEach(t=>{const r=e.vertices?e.vertices.length:0;Object.getOwnPropertyNames(t.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r].name;e.vertexBuffers[r]||e.addVertexBuffer(i,r),e[i].push(t[i])}),Object.getOwnPropertyNames(t.indexBuffers).forEach(i=>{e.indexBuffers[i]||e.addIndexBuffer(i),e[i].push(...t[i].map(t=>t+r))})}),e}compile(t=L()){for(const e in Object.getOwnPropertyNames(this.vertexBuffers).forEach(e=>{const r=this.vertexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}),this.indexBuffers){const r=this.indexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}return this.hasBeenCompiled=!0,this}static fromBinarySTL(t){return i(this,void 0,void 0,function*(){return new Promise((r,i)=>{const s=(new l).addVertexBuffer("normals","LGL_Normal"),n=new FileReader;n.onerror=i,n.onload=function(t){const i=new DataView(this.result),n=i.getUint32(80,!0);s.normals.length=3*n,s.vertices.length=3*n;let o=3*n,a=84;function h(){const t=i.getFloat32(a,!0);a+=4;const r=i.getFloat32(a,!0);a+=4;const s=i.getFloat32(a,!0);return a+=4,new e.V3(t,r,s)}for(;o;){o-=3;const t=h();s.normals[o+0]=t,s.normals[o+1]=t,s.normals[o+2]=t,s.vertices[o+0]=h(),s.vertices[o+1]=h(),s.vertices[o+2]=h(),a+=2}r(s)},n.readAsArrayBuffer(t)})})}toBinarySTL(){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const t=this.TRIANGLES,r=t.length/3,i=new ArrayBuffer(84+50*r),s=new DataView(i);s.setUint32(80,r,!0);let n=84,o=t.length;for(;o;){o-=3;const r=this.vertices[t[o]],i=this.vertices[t[o+1]],a=this.vertices[t[o+2]];[e.V3.normalOnPoints(r,i,a),r,i,a].forEach(t=>{s.setFloat32(n,t.x,!0),n+=4,s.setFloat32(n,t.y,!0),n+=4,s.setFloat32(n,t.z,!0),n+=4}),n+=2}return e.assert(n==i.byteLength,n+" "+i.byteLength),new Blob([i],{type:"application/octet-stream"})}transform(t){const e=new l;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","LGL_Normal");const r=t.as3x3().inversed().transposed().normalized();e.normals=this.normals.map(t=>r.transformVector(t).unit())}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];return e.compile(),e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","LGL_Normal");const t=this.TRIANGLES,e=this.vertices,r=this.normals;r.length=e.length;for(let i=0;i<t.length;i+=3){const s=t[i],n=t[i+1],o=t[i+2],a=e[s],h=e[n],c=e[o],l=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s].plus(l),r[n]=r[n].plus(l),r[o]=r[o].plus(l)}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this.hasBeenCompiled=!1,this}computeWireframeFromFlatTriangles(t="LINES"){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");const e=new Set;function r(t,e){return a(t,e)<<16|h(t,e)}const i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)e.add(r(i[t+0],i[t+1])),e.add(r(i[t+1],i[t+2])),e.add(r(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),e.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(t="LINES"){if(!this.TRIANGLES)throw new Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const e=this.TRIANGLES;this[t]||this.addIndexBuffer(t);const r=this[t];for(let t=0;t<e.length;t+=3)e[t+0]<e[t+1]&&r.push(e[t+0],e[t+1]),e[t+1]<e[t+2]&&r.push(e[t+1],e[t+2]),e[t+2]<e[t+0]&&r.push(e[t+2],e[t+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.normals)throw new Error("normals must be defined.");const r=this.vertices,i=this.vertices.length;this[e]||this.addIndexBuffer(e);for(let s=0;s<this.normals.length;s++)r[i+s]=r[s].plus(this.normals[s].toLength(t)),this[e].push(i+s,s);return this.hasBeenCompiled=!1,this}getAABB(){return(new e.AABB).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const r=t.detailX||t.detail||1,i=t.detailY||t.detail||1,s=t.startX||0,n=t.startY||0,o=t.width||1,a=t.height||1,h=(new l).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal").addVertexBuffer("coords","LGL_TexCoord");for(let t=0;t<=i;t++){const c=t/i;for(let l=0;l<=r;l++){const d=l/r;if(h.vertices.push(new e.V3(s+d*o,n+c*a,0)),h.coords.push([d,c]),h.normals.push(e.V3.Z),l<r&&t<i){const e=l+t*(r+1);h.TRIANGLES.push(e,e+r+1,e+1,e+r+1,e+r+2,e+1)}}}for(let t=0;t<r;t++)h.LINES.push(t,t+1),h.LINES.push((r+1)*i+t,(r+1)*i+t+1);for(let t=0;t<i;t++)h.LINES.push(r*t,r*(t+1)+1),h.LINES.push(r*(t+1),r*(t+2)+1);return h.compile(),h}static cube(){const t=(new l).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),r=[0,1,2,3,4,5,6,7,0,4,1,5,2,6,3,7,2,6,0,4,3,7,1,5];t.vertices=r.map(t=>l.UNIT_CUBE_CORNERS[t]),t.normals=[e.V3.X.negated(),e.V3.X,e.V3.Y.negated(),e.V3.Y,e.V3.Z.negated(),e.V3.Z].map(t=>[t,t,t,t]).concatenated();for(let e=0;e<24;e+=4)_(t.TRIANGLES,0!=e%8,r[e],r[e+1],r[e+2],r[e+3]);return t.LINES=[0,1,0,2,1,3,2,3,0,4,1,5,2,6,3,7,4,5,4,6,5,7,6,7].map(t=>r.indexOf(t)),t.compile(),t}static isocahedron(){return l.sphere(0)}static sphere2(t,r){const i=e.arrayFromFunction(t,r=>{const i=r/(t-1)*o-o/2;return new e.V3(0,s(i),n(i))});return l.rotation(i,{anchor:e.V3.O,dir1:e.V3.Z},2*o,r,!0,i)}static sphere(t=3){const r=(1+Math.sqrt(5))/2,i=new e.V3(1,r,0).unit(),s=i.x,n=i.y,o=[new e.V3(-s,n,0),new e.V3(s,n,0),new e.V3(-s,-n,0),new e.V3(s,-n,0),new e.V3(0,-s,n),new e.V3(0,s,n),new e.V3(0,-s,-n),new e.V3(0,s,-n),new e.V3(n,0,-s),new e.V3(n,0,s),new e.V3(-n,0,-s),new e.V3(-n,0,s)],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];function h(t,e,r,i,s,n,o,a,c,l){if(0==i)n.push(o,a,c),o<a&&l.push(o,a),a<c&&l.push(a,c),c<o&&l.push(c,o);else{const d=t.plus(e).toLength(1),f=e.plus(r).toLength(1),u=r.plus(t).toLength(1),m=s.length,E=m+1,p=m+2;s.push(d,f,u),h(d,f,u,i-1,s,n,m,E,p,l),h(t,d,u,i-1,s,n,o,m,p,l),h(e,f,d,i-1,s,n,a,E,m,l),h(r,u,f,i-1,s,n,c,p,E,l)}}const c=(new l).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");c.vertices.push(...o),t=void 0==t?4:t;for(let e=0;e<20;e++){const[r,i,s]=a.slice(3*e,3*e+3);h(o[r],o[i],o[s],t,c.vertices,c.TRIANGLES,r,i,s,c.LINES)}return c.normals=c.vertices,c.compile(),c}static aabb(t){const r=e.M4.multiplyMultiple(e.M4.translate(t.min),e.M4.scale(t.size().max(new e.V3(e.NLA_PRECISION,e.NLA_PRECISION,e.NLA_PRECISION)))),i=l.cube().transform(r);return i.computeNormalLines(20),i.compile(),i}static offsetVertices(t,r,i,s){e.assertVectors.apply(void 0,t),e.assertVectors(r);const n=(new l).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","LGL_TexCoord");s&&n.addVertexBuffer("normals","LGL_Normal"),n.vertices=t.concat(t.map(t=>t.plus(r)));const o=t.length;n.coords=e.arrayFromFunction(2*o,t=>[t%o/o,t/o|0]);const a=n.TRIANGLES;for(let e=0;e<t.length-1;e++)_(a,!1,e,e+1,t.length+e,t.length+e+1);return i&&_(a,!1,0,t.length-1,t.length,2*t.length-1),s&&(n.normals=s.concat(s)),n.compile(),n}static rotation(t,r,i,s,n=!0,o){const a=(new l).addIndexBuffer("TRIANGLES");o&&a.addVertexBuffer("normals","LGL_Normal");const h=t.length,c=h*s,d=new e.M4,f=a.TRIANGLES;for(let l=0;l<s;l++){const u=i/s*l;if(e.M4.rotateLine(r.anchor,r.dir1,u,d),a.vertices.push(...d.transformedPoints(t)),o&&a.normals.push(...d.transformedVectors(o)),n||l!==s-1)for(let t=0;t<h-1;t++)_(f,!1,l*h+t+1,l*h+t,((l+1)*h+t+1)%c,((l+1)*h+t)%c)}return a.compile(),a}static parametric(t,r,i,s,n,o,a,h){const c=(new l).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES");for(let l=0;l<=a;l++){const d=e.lerp(i,s,l/a);for(let i=0;i<=h;i++){const s=e.lerp(n,o,i/h);if(c.vertices.push(t(d,s)),c.normals.push(r(d,s)),i<h&&l<a){const t=i+l*(h+1);_(c.TRIANGLES,!1,t,t+h+1,t+1,t+h+2)}}}return c.compile(),c}static load(t){const r=new l;if(!Array.isArray(t.vertices[0]))throw new Error;return r.vertices=t.vertices.map(t=>e.V(t)),t.triangles&&(r.addIndexBuffer("TRIANGLES"),r.TRIANGLES=t.triangles),t.normals&&(r.addVertexBuffer("normals","LGL_Normal"),r.normals=t.normals),r.compile(),r}}l.UNIT_CUBE_CORNERS=[e.V3.O,new e.V3(0,0,1),new e.V3(0,1,0),new e.V3(0,1,1),new e.V3(1,0,0),new e.V3(1,0,1),new e.V3(1,1,0),e.V3.XYZ];const d=WebGLRenderingContext;var f;(f=t.DRAW_MODES||(t.DRAW_MODES={}))[f.POINTS=d.POINTS]="POINTS",f[f.LINES=d.LINES]="LINES",f[f.LINE_STRIP=d.LINE_STRIP]="LINE_STRIP",f[f.LINE_LOOP=d.LINE_LOOP]="LINE_LOOP",f[f.TRIANGLES=d.TRIANGLES]="TRIANGLES",f[f.TRIANGLE_STRIP=d.TRIANGLE_STRIP]="TRIANGLE_STRIP",f[f.TRIANGLE_FAN=d.TRIANGLE_FAN]="TRIANGLE_FAN";const u={[t.DRAW_MODES.POINTS]:t=>!0,[t.DRAW_MODES.LINES]:t=>0==t%2,[t.DRAW_MODES.LINE_STRIP]:t=>t>2,[t.DRAW_MODES.LINE_LOOP]:t=>t>2,[t.DRAW_MODES.TRIANGLES]:t=>0==t%3,[t.DRAW_MODES.TRIANGLE_STRIP]:t=>t>3,[t.DRAW_MODES.TRIANGLE_FAN]:t=>t>3};function m(t){return Float32Array==t.constructor||Float64Array==t.constructor||Array.isArray(t)&&t.every(t=>"number"==typeof t)}function E(t){return!![Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].some(e=>t instanceof e)||(t instanceof Float32Array||t instanceof Float64Array||Array.isArray(t))&&t.every(t=>Number.isInteger(t))}class p{constructor(t,e,r=L()){this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1;const i="\n\t\tuniform mat3 LGL_NormalMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrix;\n\t\tuniform mat4 LGL_ProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\t\tuniform mat4 LGL_ModelViewMatrixInverse;\n\t\tuniform mat4 LGL_ProjectionMatrixInverse;\n\t\tuniform mat4 LGL_ModelViewProjectionMatrixInverse;\n\t",s=i+"\n\t\tattribute vec4 LGL_Vertex;\n\t\tattribute vec2 LGL_TexCoord;\n\t\tattribute vec3 LGL_Normal;\n\t\tattribute vec4 LGL_Color;\n\t",n="  precision highp float;"+i,o=i.match(/\bLGL_\w+/g);function a(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,d.COMPILE_STATUS))throw new Error("compile error: "+r.getShaderInfoLog(i));return i}this.gl=r;const h=r.createProgram();if(h||r.handleError(),this.program=h,r.attachShader(this.program,a(d.VERTEX_SHADER,s+t)),r.attachShader(this.program,a(d.FRAGMENT_SHADER,n+e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,d.LINK_STATUS))throw new Error("link error: "+r.getProgramInfoLog(this.program));this.attributes={},this.uniformLocations={},this.activeMatrices={},o&&o.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,d.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}r.handleError()}static create(t,e){return new p(t,e)}uniforms(t){const r=this.gl;for(const i in r.useProgram(this.program),r.handleError(),t){const s=this.uniformLocations[i]||r.getUniformLocation(this.program,i);if(!s&&console.warn(i+" uniform is not used in shader"),!s)continue;this.uniformLocations[i]=s;let n=t[i];const o=this.uniformInfos[i];if(e.NLA_DEBUG&&(r.SAMPLER_2D!=o.type&&r.SAMPLER_CUBE!=o.type&&r.INT!=o.type||(1==o.size?e.assert(Number.isInteger(n)):e.assert(E(n)&&n.length==o.size,"value must be int array if info.size != 1")),e.assert(r.FLOAT!=o.type||1==o.size&&"number"==typeof n||m(n)&&o.size==n.length),e.assert(r.FLOAT_VEC3!=o.type||1==o.size&&n instanceof e.V3||Array.isArray(n)&&o.size==n.length&&e.assertVectors(...n)),e.assert(r.FLOAT_VEC4!=o.type||1!=o.size||m(n)&&4==n.length),e.assert(r.FLOAT_MAT4!=o.type||n instanceof e.M4,()=>n.toSource()),e.assert(r.FLOAT_MAT3!=o.type||9==n.length||n instanceof e.M4)),n instanceof e.V3&&(n=n.toArray()),r.FLOAT_VEC4==o.type&&1!=o.size)r.uniform4fv(s,n.concatenated());else if(n.length)switch(n.length){case 1:r.uniform1fv(s,n);break;case 2:r.uniform2fv(s,n);break;case 3:r.uniform3fv(s,n);break;case 4:r.uniform4fv(s,n);break;case 9:r.uniformMatrix3fv(s,!1,new Float32Array([n[0],n[3],n[6],n[1],n[4],n[7],n[2],n[5],n[8]]));break;case 16:r.uniformMatrix4fv(s,!1,new Float32Array([n[0],n[4],n[8],n[12],n[1],n[5],n[9],n[13],n[2],n[6],n[10],n[14],n[3],n[7],n[11],n[15]]));break;default:throw new Error("don't know how to load uniform \""+i+'" of length '+n.length)}else if("number"==typeof n)r.SAMPLER_2D==o.type||r.SAMPLER_CUBE==o.type||r.INT==o.type?r.uniform1i(s,n):r.uniform1f(s,n);else if("boolean"==typeof n)r.uniform1i(s,+n);else{if(!(n instanceof e.M4))throw new Error('attempted to set uniform "'+i+'" to invalid value '+n);{const t=n.m;if(r.FLOAT_MAT4==o.type)r.uniformMatrix4fv(s,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(r.FLOAT_MAT3==o.type)r.uniformMatrix3fv(s,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(r.FLOAT_MAT2!=o.type)throw new Error(`Can't assign M4 to ${o.type}`);r.uniformMatrix2fv(s,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}r.handleError()}return this}draw(r,i=t.DRAW_MODES.TRIANGLES,s,n){e.assert(r.hasBeenCompiled,"mesh.hasBeenCompiled"),e.assert(void 0!=t.DRAW_MODES[i]);const o=t.DRAW_MODES[i];return this.drawBuffers(r.vertexBuffers,r.indexBuffers[o],i,s,n)}drawBuffers(r,i,s=t.DRAW_MODES.TRIANGLES,n=0,o){const a=this.gl;a.handleError(),e.assert(void 0!=t.DRAW_MODES[s]),e.assertf(()=>1<=Object.keys(r).length),Object.keys(r).forEach(t=>e.assertInst(w,r[t]));const h=this.activeMatrices,c=(h.LGL_ModelViewMatrixInverse||h.LGL_NormalMatrix)&&a.modelViewMatrix.inversed(),l=h.LGL_ProjectionMatrixInverse&&a.projectionMatrix.inversed(),f=(h.LGL_ModelViewProjectionMatrix||h.LGL_ModelViewProjectionMatrixInverse)&&a.projectionMatrix.times(a.modelViewMatrix),m={};h.LGL_ModelViewMatrix&&this.modelViewMatrixVersion!=a.modelViewMatrixVersion&&(m.LGL_ModelViewMatrix=a.modelViewMatrix),h.LGL_ModelViewMatrixInverse&&(m.LGL_ModelViewMatrixInverse=c),h.LGL_ProjectionMatrix&&this.projectionMatrixVersion!=a.projectionMatrixVersion&&(m.LGL_ProjectionMatrix=a.projectionMatrix),l&&(m.LGL_ProjectionMatrixInverse=l),f&&(m.LGL_ModelViewProjectionMatrix=f),f&&h.LGL_ModelViewProjectionMatrixInverse&&(m.LGL_ModelViewProjectionMatrixInverse=f.inversed()),h.LGL_NormalMatrix&&this.modelViewMatrixVersion!=a.modelViewMatrixVersion&&(m.LGL_NormalMatrix=c.transposed()),this.uniforms(m),this.projectionMatrixVersion=a.projectionMatrixVersion,this.modelViewMatrixVersion=a.modelViewMatrixVersion;let E=1/0;for(const t in r){const i=r[t];e.assert(i.hasBeenCompiled);const s=this.attributes[t]||a.getAttribLocation(this.program,t);a.handleError(),-1!=s&&i.buffer&&(this.attributes[t]=s,a.bindBuffer(d.ARRAY_BUFFER,i.buffer),a.handleError(),a.enableVertexAttribArray(s),a.handleError(),a.vertexAttribPointer(s,i.spacing,d.FLOAT,!1,0,0),a.handleError(),E=Math.min(E,i.count))}for(const t in this.attributes)t in r||(a.disableVertexAttribArray(this.attributes[t]),a.handleError());if(E){if(o=o||(i?i.count:E),e.assert(u[s](o),"count "+o+" doesn't fulfill requirement "+u[s].toString()+" for mode "+t.DRAW_MODES[s]),i){if(e.assert(i.hasBeenCompiled),e.assert(E>i.maxValue),e.assert(o%i.spacing==0),e.assert(n%i.spacing==0),n+o>i.count)throw new Error("Buffer not long enough for passed parameters start/length/buffer length "+n+" "+o+" "+i.count);a.bindBuffer(d.ELEMENT_ARRAY_BUFFER,i.buffer),a.handleError(),a.drawElements(s,o,d.UNSIGNED_SHORT,2*n),a.handleError()}else{if(n+o>E)throw new Error("invalid");a.drawArrays(s,n,o),a.handleError()}a.drawCallCount++}return this}}function L(){return A.gl}const x=WebGLRenderingContext;class A{constructor(t,r={mesh:(new l).addVertexBuffer("coords","LGL_TexCoord").addVertexBuffer("colors","LGL_Color"),mode:-1,coord:[0,0],color:[1,1,1,1],pointSize:1,shader:new p("\n            uniform float pointSize;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                color = LGL_Color;\n                coord = LGL_TexCoord;\n                gl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n                gl_PointSize = pointSize;\n            }\n        ","\n            uniform sampler2D texture;\n            uniform float pointSize;\n            uniform bool useTexture;\n            varying vec4 color;\n            varying vec2 coord;\n            void main() {\n                gl_FragColor = color;\n                if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n            }\n        ",t)}){this.immediate=r,this.modelViewMatrix=new e.M4,this.projectionMatrix=new e.M4,this.MODELVIEW=A.MODELVIEW,this.PROJECTION=A.PROJECTION,this.tempMatrix=new e.M4,this.resultMatrix=new e.M4,this.modelViewStack=[],this.projectionStack=[],this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.matrixMode(A.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw new Error("invalid matrix mode "+t)}}loadIdentity(){e.M4.identity(this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}loadMatrix(t){e.M4.copy(t,this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}multMatrix(t){e.M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const r=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=r,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(e.M4.mirror(t))}perspective(t,r,i,s,n){this.multMatrix(e.M4.perspectiveRad(t*e.DEG,r,i,s,this.tempMatrix))}frustum(t,r,i,s,n,o){this.multMatrix(e.M4.frustum(t,r,i,s,n,o,this.tempMatrix))}ortho(t,r,i,s,n,o){this.multMatrix(e.M4.ortho(t,r,i,s,n,o,this.tempMatrix))}scale(...t){this.multMatrix(e.M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(e.M4.mirror(e.P3ZX))}translate(t,r,i){void 0!==r?this.multMatrix(e.M4.translate(t,r,i,this.tempMatrix)):this.multMatrix(e.M4.translate(t,this.tempMatrix))}rotate(t,r,i,s){this.multMatrix(e.M4.rotate(t*e.DEG,{x:r,y:i,z:s},this.tempMatrix))}lookAt(t,r,i){this.multMatrix(e.M4.lookAt(t,r,i,this.tempMatrix))}pushMatrix(){this.stack.push(e.M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();e.assert(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[r,i,s,n]=t,o=new e.M4([s/2,0,0,r+s/2,n/2,0,0,i+n/2,0,0,1,0,0,0,0,1]);return e.M4.multiplyMultiple(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){var e;this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?[((e=t[0])>>16)/255,(e>>8&255)/255,(255&e)/255,1]:1==t.length&&"string"==typeof t[0]?r(t[0]).gl():[t[0],t[1],t[2],t[3]||0]}texCoord(...t){this.immediate.coord=e.V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(e.V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw new Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!A.gl.getParameter(x.TEXTURE_BINDING_2D)}).drawBuffers(this.immediate.mesh.vertexBuffers,void 0,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){A.gl=this}animate(t){const e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let r=performance.now(),i=!0;const s=n=>{const o=performance.now();t.call(this,o,o-r),r=o,i&&e(s)};return e(s),()=>{i=!1}}fullscreen(t={}){const e=t.paddingTop||0,r=t.paddingLeft||0,i=t.paddingRight||0,s=t.paddingBottom||0;if(!document.body)throw new Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");document.body.appendChild(this.canvas),document.body.style.overflow="hidden",this.canvas.style.position="absolute",this.canvas.style.left=r+"px",this.canvas.style.top=e+"px";const n=this;function o(){n.canvas.width=window.innerWidth-r-i,n.canvas.height=window.innerHeight-e-s,n.viewport(0,0,n.canvas.width,n.canvas.height),t.camera&&(n.matrixMode(A.PROJECTION),n.loadIdentity(),n.perspective(t.fov||45,n.canvas.width/n.canvas.height,t.near||.1,t.far||1e3),n.matrixMode(A.MODELVIEW))}return window.addEventListener("resize",o),o(),this}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}handleError(){}static create(t={}){const r=t.canvas||document.createElement("canvas");t.canvas||(r.width=800,r.height=600),"alpha"in t||(t.alpha=!1);let i=void 0;try{i=r.getContext("webgl",t),console.log("getting context")}catch(t){console.log(t,i)}try{i=i||r.getContext("experimental-webgl",t)}catch(t){console.log(t,i)}if(!i)throw new Error("WebGL not supported");return A.gl=i,e.addOwnProperties(i,A.prototype),e.addOwnProperties(i,new A(i)),i}}var M;function _(t,e,r,i,s,n){e?t.push(r,s,i,i,s,n):t.push(r,i,s,i,n,s)}A.MODELVIEW=0,A.PROJECTION=1,A.HALF_FLOAT_OES=36193,function(t){t[t.NO_ERROR=x.NO_ERROR]="NO_ERROR",t[t.INVALID_ENUM=x.INVALID_ENUM]="INVALID_ENUM",t[t.INVALID_VALUE=x.INVALID_VALUE]="INVALID_VALUE",t[t.INVALID_OPERATION=x.INVALID_OPERATION]="INVALID_OPERATION",t[t.INVALID_FRAMEBUFFER_OPERATION=x.INVALID_FRAMEBUFFER_OPERATION]="INVALID_FRAMEBUFFER_OPERATION",t[t.OUT_OF_MEMORY=x.OUT_OF_MEMORY]="OUT_OF_MEMORY",t[t.CONTEXT_LOST_WEBGL=x.CONTEXT_LOST_WEBGL]="CONTEXT_LOST_WEBGL"}(M||(M={})),A.prototype.MODELVIEW=A.MODELVIEW,A.prototype.PROJECTION=A.PROJECTION,A.prototype.HALF_FLOAT_OES=A.HALF_FLOAT_OES;const g=WebGLRenderingContext;class w{constructor(t,r){this.target=t,this.type=r,e.assert(t==g.ARRAY_BUFFER||t==g.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),e.assert(r==Float32Array||r==Uint16Array,"type == Float32Array || type == Uint16Array"),this.buffer=void 0,this.type=r,this.data=[],this.count=0,this.spacing=0,this.hasBeenCompiled=!1}compile(t=g.STATIC_DRAW,r=L()){let i;if(e.assert(g.STATIC_DRAW==t||g.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),r.handleError(),this.buffer=this.buffer||r.createBuffer(),r.handleError(),0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof e.V3)e.assert(!(this.data[0]instanceof e.V3)||this.type==Float32Array),e.V3.pack(this.data,i=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;i=new this.type(t);let r=this.data.length,s=t;for(;r--;){const t=this.data[r];let e=t.length;for(;e--;)i[--s]=t[e]}e.assert(0==s)}else i=new this.type(this.data);const t=this.data.length?i.length/this.data.length:0;e.assert(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),e.NLA_DEBUG&&(1e4<=i.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,i)),e.assert(0!==t),this.spacing=t,this.count=this.data.length}r.bindBuffer(this.target,this.buffer),r.handleError(),r.bufferData(this.target,i,t),r.handleError(),this.hasBeenCompiled=!0}}class R{constructor(t,e,r={},i=L()){this.gl=i,this.texture=i.createTexture(),i.handleError(),this.width=t,this.height=e,this.format=r.format||i.RGBA,this.type=r.type||i.UNSIGNED_BYTE;const s=r.filter||r.magFilter||i.LINEAR,n=r.filter||r.minFilter||i.LINEAR;if(this.type===i.FLOAT){if(!i.getExtension("OES_texture_float"))throw new Error("OES_texture_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw new Error("OES_texture_float_linear is required but not supported")}else if(this.type===A.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw new Error("OES_texture_half_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw new Error("OES_texture_half_float_linear is required but not supported")}i.bindTexture(i.TEXTURE_2D,this.texture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,r.wrap||r.wrapS||i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,r.wrap||r.wrapT||i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,this.format,t,e,0,this.format,this.type,null)}bind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}unbind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}canDrawTo(){const t=this.gl;this.framebuffer=this.framebuffer||t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0);const e=t.checkFramebufferStatus(t.FRAMEBUFFER)==t.FRAMEBUFFER_COMPLETE;return t.bindFramebuffer(t.FRAMEBUFFER,null),e}drawTo(t){const e=this.gl;if(this.framebuffer=this.framebuffer||e.createFramebuffer(),this.renderbuffer=this.renderbuffer||e.createRenderbuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.bindRenderbuffer(e.RENDERBUFFER,this.renderbuffer),this.width==this.renderbuffer.width&&this.height==this.renderbuffer.height||(this.renderbuffer.width=this.width,this.renderbuffer.height=this.height,e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.renderbuffer),e.checkFramebufferStatus(e.FRAMEBUFFER)!=e.FRAMEBUFFER_COMPLETE)throw new Error("Rendering to this texture is not supported (incomplete this.framebuffer)");const r=e.getParameter(e.VIEWPORT);e.viewport(0,0,this.width,this.height),t(e),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.viewport(r[0],r[1],r[2],r[3])}swapWith(t){let r;e.assert(this.gl==t.gl),r=t.texture,t.texture=this.texture,this.texture=r,r=t.width,t.width=this.width,this.width=r,r=t.height,t.height=this.height,this.height=r}static fromImage(t,e,r=L()){e=e||{};const i=new R(t.width,t.height,e,r);try{r.texImage2D(r.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?new Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):new Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=r.NEAREST&&e.minFilter!=r.LINEAR&&r.generateMipmap(r.TEXTURE_2D),i}static fromURL(t,e={},r=L()){R.checkerBoardCanvas=R.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw new Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=R.fromImage(R.checkerBoardCanvas,e),s=new Image;return s.onload=(()=>R.fromImage(s,e,r).swapWith(i)),s.src=t,i}}t.Buffer=w,t.Mesh=l,t.SHADER_VAR_TYPES=["FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT"],t.isArray=function(t){return Array==t.constructor||Float32Array==t.constructor||Float64Array==t.constructor},t.Shader=p,t.Texture=R,t.GL_COLOR_BLACK=[0,0,0,1],t.currentGL=L,t.isNumber=function(t){const e=Object.prototype.toString.call(t);return"[object Number]"==e||"[object Boolean]"==e},t.LightGLContext=A,t.pushQuad=_,Object.defineProperty(t,"__esModule",{value:!0})});